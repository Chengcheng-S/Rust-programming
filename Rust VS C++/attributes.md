## Attributes

C++在编译过程中有多种方式给出编译器指令：

> 预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。
>
> 预处理指令是在编译器进行编译之前进行的操作.预处理过程扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。
>
> 在编译时包含其他源文件、定义宏、根据条件决定编译时是否包含某些代码(防止重复包含某些文件)。要完成这些工作，就需要使用预处理程序。

- 编译控制多行行为的标志
- `#pragma` 预处理指令 -`once` `optimize` `comment` `pack`  
- `#define`  定义宏
- 关键字`inline` `const` `volatile` 这些提示代码并允许编译器做出可能更改其输出或优化的决策。
- `#include` 包含一个源代码文件
- `#ifdef` 如果宏已定义则编译下边的程序
- `#if` 若条件为真，则编译
- `#ifndef` 若宏没有定义，则编译下面的程序
- `#error` 停止编译并显示错误信息。

定义宏：

```c++
#include <stdio.h>
#define MAX(x,y) (((x)>(y)?(x):(y)))  //尽量使用小括号，将参数括起来。
#define MIN(x,y) (((x)<(y)?(x):(y)))

int main(void)
{
#ifdef MAX  // 只需要宏名即可，无需参数
    printf("%d\n",MAX(3,5));
#endif

#ifdef MIN
    printf("%d\n",MIN(3,5));
#endif
    retrun 0;
}
```

Rust中使用了一种称为attribute的表示法，作用类似于c++中的编译器指令，

`#[foo]`类型：应用于之前声明的下一项。

```rust
#[test]
fn this_is_test(){
    // test
}
```

属性也可以表示为`#![foo]`：影响到它们所包含的东西，而不是它们后面的东西。

```rust
fn this_is_test(){
	#![test]
}
```

属性被包含在`#[]` 内，并提供编译器指令：

- 标记为单元测试or基准测试
- 为目标操作系统标记为条件编译的函数，可以定义只位一个目标编译的函数。
- 禁用/启用`lint` 规则
- 禁用/启用编译器功能，Rust的某些特性是处于实验阶段的，使用之前需要进行声明
- 将程序的入口更改为其他的函数`#[main]`
- 根据目标体系结构、操作系统等条件进行编译
- 内联函数
- 使用某些的triat
- 启用编译器某些功能
- 从其他的模块引用宏

### 条件编译

条件编译可以测试目标配置，并选择是否编译函数或者模块，主要包括：

- Target architecture - x86、x86_64、mips、arm
- OS  windows  linux ios  android macos
- family  unix  windows
- envrionment  gun  msvc

```c++
#[cfg(windows)]
fn get_app_data_dir() -> String { /* ... */ }
#[cfg(not(windows))]
fn get_app_data_dir() -> String { /* ... */ }
```

### 连接到本地库

在C/C++代码中首先编译，然后通过附加的参数到编译器，或者通过调用链接器来链接。

Rust中使用`cargo`

| C++                            | Rust                                         |
| :----------------------------- | :------------------------------------------- |
| `#pragma (comment, "somelib")` | `#[link(name = "somelib")]`                  |
| -                              | `#[link(name = "somelib", kind = "static")]` |

`#link`的默认类型是dynamic library，但可以显式指定`static`。

### 内联程序

> 内联发生在函数逻辑插入到调用它的代码的地方。当函数执行一些琐碎的操作（如返回值或执行简单的条件）时，就会发生这种情况。性能超过了复制代码的开销优点.内联在函数逻辑插入到调用它的代码的地方发生。当函数执行一些琐碎的操作（如返回值或执行简单的条件）时，就会发生这种情况。复制代码的开销被性能优势所抵消。

- 内联通过在标题中声明和实现函数、类方法或模板方法或用内联关键字标记来实现C++。
- 在Rust中，内联只是一个提示。Rust建议不要强制内联，而是将其作为一个提示留给LLVM编译器处理。

| C++                                                          | Rust                                                 |
| :----------------------------------------------------------- | :--------------------------------------------------- |
| Explicitly with `inline` or implicitly through methods implemented in class / struct | `#[inline]`, `#[inline(always)]`, `#[inline(never)]` |



显式内联代码的另一种替代方法是在LLVM中使用链接时间优化。

```
rusc -C ito
```

