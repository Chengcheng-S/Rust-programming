## 布局

### 头文件

#### C/C++

C/C++的通用文件文件大致分为两种：

- `.h`、`.hpp` （头文件）包含类定义，外部函数签名、宏、模板、内联函数。有时内联函数会存储在自己的文件中。标注模板库C++头文件没有文件扩展名，某些第三方库可能会省略改扩展名。
- `.c`、`.cc`、`.cpp` （源文件）包含类的实现以及任何私有内容。有时，C ++将使用诸如前向类引用和Pimpl模式之类的技巧来将复杂的代码或从属代码保留在头文件之外。

对于某些情况下出现的`.inl`,`,ipp`文件，这些文件是带有许多内联模板或函数的头文件。

> 大多数C / C ++代码中编译过程：预处理器根据其中的＃指令将各种头文件连接到源文件的开头，并将结果文件馈入编译器。在多个文件之间拆分定义和实现可能很麻烦，因为这意味着更改单个类可能需要修改多个文件。

#### Rust

Rust中并没有头文件，每个struct、implementation、macro都位于单独的rs文件之中。 各模块之间通过`pub`关键字选择是否声明为公有，`use`关键字进行模块引用。

### 命名空间

#### C/C++

C不使用命名空间，标准库倾向于在其功能和结构的前面加上某种限定名称。 C ++确实有名称空间，但是它们的使用是可选的，并且从一段代码到另一段代码都不同。

#### Rust

Rust具有类似于#include的模块，并将名称空间合并为一个。

### 文件命名

C/C++文件后缀为：

- `.h`、`.hpp`、`.inl` 头文件或内联程序
- `.c`、`.cpp`、`.cc` 源码

Rust文件为snake_case命名法，并以.rs结尾。名称是模块名称，其范围限定了其中的内容。还有一些特殊文件，分别称为main.rs，lib.rs和mod.rs。如果将文件命名为foo.rs，则当外部引用时，内部所有内容的作用域均为`foo :: *`

### Unicode 支持

C和C ++标准的最新实现为UTF编码提供了字符串文字类型，但在此之前，它严格是ascii或宽字符(wchar_t)处理函数。

C/C++中Unicode准则：

- 源代码通常金科安全使用`0-127`字符，即使编译器允许makefile指定其他的编码参数。
- C++具有8位和32位或16位的`wchar_t`或`char`类型，`wchar_t`的问题是宽度立即被破坏。
- `char`表示没有编码，通常表示ASCII 、UTF-8、Larin1或者其他编码格式，具体由程序来定。
- wchar_t不是UTF-32。在某些平台（如Windows）上，可能是UTF-16，也可能是UTF-16。这种混乱的定义使诸如切片字符串之类的操作由于切穿控制点的风险而非常危险。
- C标准库 已有strdup，strcmp，strcpy等的各种广泛版本。它还有用于在磁盘上打开文件的函数的多种版本。
- C++ 标准库也有了`std::string`,`std::wstring`类，也有了这些类型的UTF-16、UTF-32版本。
- C11和C++ 11为各种UTF宽度引入显式字符串文字。
- 在C++中`wide`和`narrow`可以进行转换，但是某些操作系统的转换功能并不是很完整。
- 通常使用ICU4C之类的第三方转换库。像boost，Qt之类的库使用libicu在编码之间进行转换
- 将Unicode嵌入到C源码中设计使用转移吗或十六进制值。

#### Rust

这一方面Rust并没有C/C++那么繁琐

- 源码是UTF-8编码的
- 注释、字符和字符串文字可以包含Unicode字符而无需转义。
- 本机char类型为4个字节宽–与Unicode字符一样宽。
- 本地str和String类型在内部为UTF-8，以节省空间，但可以根据函数的功能通过char或按字节进行迭代。

