### [E0500]
```rust
fn main() {
}
fn f1(s :&mut i32){
    let x=&s;
    let y=||{
        *s=5;
    };
    println!("{}",x);
}
```
result:
```
error[E0500]: closure requires unique access to `s` but it is already borrowed
 --> src\main.rs:5:11
  |
4 |     let x=&s;
  |           -- borrow occurs here
5 |     let y=||{
  |           ^^ closure construction occurs here
6 |         *s=5;
  |          - second borrow occurs due to use of `s` in closure
7 |     };
8 |     println!("{}",x);
  |                   - first borrow later used here
```
describe:借用变量由闭包使用
solution：可以借用结束后创建闭包
```rust
fn main() {}

fn f1(s: &mut i32) {
    let x = &s;
    println!("{}", x);
    let y = || {
        *s = 5;
    };
}
```
Or:如果该类型实现Clone特性，则可以在闭包之间克隆它
```rust
fn main() {}

fn f1(s: &mut i32) {
    let x = s.clone();

    let y = || {
        *s = 5;
    };
    println!("{}", x);
}
```
### [E0501]
```rust
fn main() {}

fn f1(x:&mut i32){}
fn f2(x:&mut i32){}
fn f3(a:&mut i32){
    let mut bar=||{
        f1(a)
    };
    f2(a);
    bar()
}
```
result:
```
error[E0501]: cannot borrow `*a` as mutable because previous closure requires unique a
ccess
  --> src\main.rs:9:8
   |
6  |     let mut bar=||{
   |                 -- closure construction occurs here
7  |         f1(a)
   |            - first borrow occurs due to use of `a` in closure
8  |     };
9  |     f2(a);
   |        ^ second borrow occurs here
10 |     bar()
   |     --- first borrow later used here
```
describe:使用了可变变量，但已由闭包捕获
>此错误表明在变量仍被闭包捕获时使用了可变变量。
>因为闭包借用了变量，所以直到闭包出了作用域才可用。

注：捕获将移动或借用变量，但是在这种情况下，闭包正在借用该变量。
solution：使用捕获变量之前完成使用闭包的操作
```rust
fn main() {}

fn f1(x: &mut i32) {}

fn f2(x: &mut i32) {}

fn f3(a: &mut i32) {
    let mut bar = || {
        f1(a)
    };
    bar();
    f2(a);
}
```
or: 将变量作为参数传递给闭包 将FnOnce====》 FnMut
```rust
fn main() {}

fn f1(x: &mut i32) {}

fn f2(x: &mut i32) {}

fn f3(a: &mut i32) {
    let mut bar = |s:&mut i32| {
        f1(s)
    };

    f2(a);
    bar(a);
}
```
或者延迟声明，调用闭包
```rust
fn main() {}

fn f1(x: &mut i32) {}

fn f2(x: &mut i32) {}

fn f3(a: &mut i32) {
    f2(a);
    let mut bar = |s:&mut i32| {
        f1(s)
    };
    bar(a);
}
```
### [E502]
```rust
fn main() {}

fn f1(x: &mut i32) {}

fn f2(a: &mut i32) {
    let ref y=a;
    f1(a);
    println!("{}",y);
}
```
result:
```
error[E0502]: cannot borrow `*a` as mutable because it is also borrowed as immutable
 --> src\main.rs:7:5
  |
6 |     let ref y=a;
  |         ----- immutable borrow occurs here
7 |     f1(a);
  |     ^^^^^ mutable borrow occurs here
8 |     println!("{}",y);
  |                   - immutable borrow later used here
```
describe:将不可变的引用变为可变的借用。
solution:在以可变方式访问变量之前，确保没有其他任何对给变量的引用。
```rust
fn main() {}

fn f1(x: &mut i32) {}

fn f2(a: &mut i32) {
    f1(a);
    let ref y=a;
    println!("{}",y);
}
```
### [E0503]
```rust
fn main() {
    let mut x=3;
    let borr=&mut x;
    let _a= x+3;
    println!("{}",borr);
}
```
result:
```
error[E0503]: cannot use `x` because it was mutably borrowed
 --> src\main.rs:4:13
  |
3 |     let borr=&mut x;
  |              ------ borrow of `x` occurs here
4 |     let _a= x+3;
  |             ^ use of borrowed `x`
5 |     println!("{}",borr);
  |                   ---- borrow later used here
```
describe:可变借用之后使用了该值
>x 是可变的借用，不能用于计算总和，此违反了Rust的可变性规则。

通过在下次使用该值之前先完成使用借位来解决此错误：
```rust
fn main() {
    let mut x = 3;
    let borr = &mut x;
    println!("{}", borr);
    let a = x + 3;
}
```
or: 在借用之前clone值
```rust
fn main() {
    let mut x = 3;
    let x_c=x.clone();
    let borr = &mut x;

    let a = x_c + 3;
    println!("{}", borr);
}
```
### [E0504]
注：此错误不在提示
```rust
fn main() {
    let a=A{num:3};
    let a_ref=&a;
    let x=move||{
        println!("ch function:{}",a_ref.num);
    };
    x();
    println!("{}",a_ref.num);
}
struct A{
    num:u8,
}
```
describe:将借用的变量移入闭包时，会发生此错误。
>借入值时，无法将其移至封闭中，因为这会使借入无效。

如果闭包不能超过要移动的值，尝试使用引用而不是移动
必须先借用值然后移动该值，尝试使用作用域块来限制借用的寿命。
若引用的生命周期不够，例如在使用线程的情况下，使用Arc来创建引用计数的值：
```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let a = Arc::new(A { num: 3 });

    let a_ref = a.clone();

    let x = thread::spawn(move || {
        println!("ch function:{}", a.num);
    });
    x.join().expect("thread move the value");
    println!("{}", a_ref.num);
}

struct A {
    num: u8,
}
```
### [E0505]
```rust
fn main() {
    let a = A {};
    let _ref_a: &A = &a;
    f2(a);
    f1(_ref_a);
}

struct A {}

fn f1(a: &A) {}

fn f2(b: A) {}
```
result:
```
error[E0505]: cannot move out of `a` because it is borrowed
 --> src\main.rs:4:8
  |
3 |     let _ref_a: &A = &a;
  |                      -- borrow of `a` occurs here
4 |     f2(a);
  |        ^ move out of `a` occurs here
5 |     f1(_ref_a);
  |        ------ borrow later used here
```
describe:某个值仍在借用时被移出。
函数f2获取b的所有权，但是b不能移动，因为对_ref_a的借用需要持续到函数借用为止，
solution: 1、尽量避免移动变量，2、移动前释放借用，3、在类型上实现Copy triat
```rust
fn main() {
    let a = A {};
    let _ref_a: &A = &a;
    f1(_ref_a);
    f2(a);
}

struct A {}

fn f1(a: &A) {}

fn f2(a: A) {}
```
Or:
```rust
fn main() {
    let a = A {};
    let _ref_a: &A = &a;

    f2(a);
    f1(_ref_a);
}
#[derive(Copy, Clone)]
struct A {}

fn f1(a: &A) {}

fn f2(a: A) {}
```
### [E0506]
```rust
fn main() {
    let mut x= A{num:9};
    let x_ref=&x;
    x=A{num:7};

    println!("num{} ref{}",x.num,x_ref.num);
}

struct A{
    num:u8,
}
```
result:
```
error[E0506]: cannot assign to `x` because it is borrowed
 --> src\main.rs:4:5
  |
3 |     let x_ref=&x;
  |               -- borrow of `x` occurs here
4 |     x=A{num:7};
  |     ^^^^^^^^^^ assignment to borrowed `x` occurs here
5 |
6 |     println!("num{} ref{}",x.num,x_ref.num);
  |                                  --------- borrow later used here
```
describe:试图分配借用的值
由于x_ref保留有对x的引用，因此无法将x重新分配值，此操作时无效的。
将x的值移动到了x_ref 再对x进行再分配即可
```rust
fn main() {
    let mut x= A{num:9};
    let x_ref=x;
    x=A{num:7};

    println!("num{} ref{}",x.num,x_ref.num);
}

struct A{
    num:u8,
}
```
如果必须借用该值，使用作用域块来限制借用的期限。
```rust
fn main() {
    let mut x = A { num: 9 };
    {
        let x_ref = &x;
        print!("{}",x_ref.num);
    }
    x = A { num: 7 };

    println!("num{}", x.num);
}

struct A {
    num: u8,
}
```
或通过将引用移动到函数之中
```rust
fn main() {
    let mut x = A { num: 9 };

    f1(&x);

    x = A { num: 7 };

    println!("num{}", x.num);
}

struct A {
    num: u8,
}

fn f1(a: &A) {
    println!("{}", a.num);
}
```
### [E0507]
```rust
use std::cell::RefCell;

fn main() {
    let x=RefCell::new(A);
    x.borrow().fa();
}

struct A;

impl A {
    fn fa(self) {}
}
```
result:
```
error[E0507]: cannot move out of dereference of `std::cell::Ref<'_, A>`
 --> src\main.rs:5:5
  |
5 |     x.borrow().fa();
  |     ^^^^^^^^^^ move occurs because value has type `A`, which does not implement th
e `Copy` trait
```
describe:借用的值被移出
此处 f1方法获取了self的所有权，但是不能移动self，因为borrow() 仅提供了&A，它是RefCell拥有的内容的借用
solution：1、尽量避免移动所有权；2、以某种方式收回所有权；3、在类型上实现Copytriat
> 当使用实现Fn或FnMut的类型时，也可能发生此情况，
>因为它们都不允许移除它门(常表示可以多次调用的闭包)

适用于非FnOnce闭包
```rust
use std::cell::RefCell;

fn main() {
    let x=RefCell::new(A);
    x.borrow().fa();
}
#[derive(Copy, Clone)]
struct A;

impl A {
    fn fa(self) {}
}
```
or：
```rust
use std::cell::RefCell;

fn main() {
    let x=RefCell::new(A);
    x.borrow().fa();
}

struct A;

impl A {
    fn fa(&self) {}
}
```
or：
```rust
use std::cell::RefCell;

fn main() {
    let x = RefCell::new(A);
    let x = x.into_inner(); // 消耗RefCell 返回内部的值
    x.fa();
}

struct A;

impl A {
    fn fa(self) {}
}
```
into_inner() 获取内部的值
将成员移除可变借用的结构体也会导致507错误
```rust
fn main() {
    let mut b = B {
        b: A
    };
    let b_ref = &mut b;
    b_ref.b.fa();
}

struct A;

impl A {
    fn fa(self) {}
}

struct B {
    b: A
}
```
result:
````
error[E0507]: cannot move out of `b_ref.b` which is behind a mutable reference
 --> src\main.rs:6:5
  |
6 |     b_ref.b.fa();
  |     ^^^^^^^ move occurs because `b_ref.b` has type `A`, which does not implement t
he `Copy` trait
````
另一种解决方式
```rust
use std::mem;

fn main() {
    let mut b = B {
        b: A
    };
    let b_ref = &mut b;
    mem::replace(&mut b_ref.b, A).fa();
}

struct A;

impl A {
    fn fa(self) {}
}

struct B {
    b: A
}
```
`mem::replace` 如果不需要旧值，则可以直接分配新值

### [E0508]
```rust
fn main() {
    let arr=[A;1];
    let _v=arr[0];
}
struct A;
```
result:
```
error[E0508]: cannot move out of type `[A; 1]`, a non-copy array
 --> src\main.rs:3:12
  |
3 |     let _v=arr[0];
  |            ^^^^^^
  |            |
  |            cannot move out of here
  |            move occurs because `arr[_]` has type `A`, which does not implement the
 `Copy` trait
  |            help: consider borrowing here: `&arr[0]`
```
describe:移出非复制固定大小的数组元素。
>第一个元素被移出了数组，这事不可能的，因为NonCopy类型没有实现Copy trait

solution： 1、借用而不是移出
```rust
fn main() {
    let arr=[A;1];
    let _v=&arr[0];
}
struct A;
```
or: 对NonCopy实现Copy tarit
```rust
fn main() {
    let arr=[A;1];
    let _v=arr[0];
}
#[derive(Copy, Clone)]
struct A;
```
### [E0509]
```rust
fn main() {
    let b =B{a:A{num:3}};
    let b_a=b.a;
    println!("{}",b_a.num);
}
struct A{
    num:usize
}
struct B{
    a:A
}
impl Drop for B{
    fn drop(&mut self){}
}
```
result:
```
error[E0509]: cannot move out of type `B`, which implements the `Drop` trait
 --> src\main.rs:3:13
  |
3 |     let b_a=b.a;
  |             ^^^
  |             |
  |             cannot move out of here
  |             move occurs because `b.a` has type `A`, which does not implement the `
Copy` trait
  |             help: consider borrowing here: `&b.a`
```
describe；尝试移出其类型实现Drop trait的值时，会发生此错误。
>将字段移出实现Drop特性的DropStruct类型的结构。但是，如果一个结构的一个或多个字段已移动，则不能删除该结构。
>实现Drop特性的结构具有一个隐式析构函数，当它们超出范围时会被调用。该析构函数可能会使用该结构的字段，因此将其移出该结构可能无法运行该析构函数。
>因此 必须将器类型实现Drop trait的所有制都视为无法移动其字段的单个单位。

solution：使用ref关键字创建对struct，enum或tuple的字段的引用来解决此错误。
```rust
fn main() {
    let b =B{a:A{num:3}};
    let ref b_a=b.a;
    println!("{}",b_a.num);
}
struct A{
    num:usize
}
struct B{
    a:A
}
impl Drop for B{
    fn drop(&mut self){}
}
```
注：此项计数也可以在match表达式中使用
```rust
fn main() {
    let b =B::a(A{num:3});
    match b{
        B::a(ref b)=>println!("{}",b.num),
    }
}
struct A{
    num:usize
}
enum B{
    a(A)
}
impl Drop for B{
    fn drop(&mut self){}
}
```
### [E0510]
```rust
fn main() {
    let mut b = Some(0);
    match b {
        None => {}
        Some(_)if {
            b = None;
            false
        } => {}
        Some(_) => {}
    }
}
```
result:
```
error[E0510]: cannot assign `b` in match guard
 --> src\main.rs:6:13
  |
3 |     match b {
  |           - value is immutable in match guard
...
6 |             b = None;
  |             ^^^^^^^^ cannot assign
```
describe:匹配的值以再守卫匹配中分配
>在变量上进行匹配时，不能在守卫匹配中对其进行更改，因此这可能会导致匹配有遗
>在这里执行b=None将修改匹配的值

solution:修改匹配项
```rust
fn main() {
    let mut b = Some(0);
    match b {
        None => {}
        Some(_) => {
            b = None
        }
    }
}
```
### [E0511]
```rust
#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_add<T>(a: T, b: T) -> T;
}

fn main() {
    unsafe { simd_add(0, 1); }
    // error: invalid monomorphization of `simd_add` intrinsic
}
```
describe:使用了无效的内置函数单态化
泛型必须是SIMD类型
```rust
#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
#[derive(Copy, Clone)]
struct i32x2(i32, i32);

extern "platform-intrinsic" {
    fn simd_add<T>(a: T, b: T) -> T;
}

unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); }
```
### [E0512]
```rust

fn main() {
    unsafe {
        f1(::std::mem::transmute(0u16));
    }
}
fn f1(_:u8){}
```
result:
```
error[E0512]: cannot transmute between types of different sizes, or dependently-sized
types
 --> src\main.rs:4:12
  |
4 |         f1(::std::mem::transmute(0u16));
  |            ^^^^^^^^^^^^^^^^^^^^^
  |
  = note: source type: `u16` (16 bits)
  = note: target type: `u8` (8 bits)
```
describe:将两种不同大小的类型进行转换
使用相同大小的类型或直接使用期望的类型
```rust

fn main() {
    unsafe {
        f1(::std::mem::transmute(0i8));
        // or
        f1(0u8);    
}
}
fn f1(_:u8){}
```
### [E515]
```rust
fn main() {}

fn f1() -> &'static i32 {
    let x=0;
    &x
}
```
result:
```
error[E0515]: cannot return reference to local variable `x`
 --> src\main.rs:5:5
  |
5 |     &x
  |     ^^ returns a reference to data owned by the current function
```
describe:返回了对局部变量的引用
> 局部变量，函数参数和临时变量都在函数主体结束之前删除，因此不能返回对它们的引用

```rust
fn main() {}

const X: i32 = 0;

fn f1() -> &'static i32 {
    let x = 0;
    &X
}
```
###  [E0516]
```rust
fn main() {
    let x:typeof(92)=92;
}
```
result:
```
E:\mytest_ru>cargo check
    Checking mytest_ru v0.1.0 (E:\mytest_ru)
error[E0516]: `typeof` is a reserved keyword but unimplemented
 --> src\main.rs:2:11
  |
2 |     let x:typeof(92)=92;
  |           ^^^^^^^^^^ reserved keyword
```
describe:typeof是保留关键字，当前未实现
solution：使用类型推断
```rust
let x=26;
```
### [E0517]
```rust
fn main() {}
#[repr(C)]
type A=u8;

#[repr(packed)]
enum Foo{bar,baz}

#[repr(u8)]
struct S {bar: bool, baz: bool}

#[repr(C)]
impl Foo {}
```
result:
```
error[E0517]: attribute should be applied to struct, enum, or union
 --> src\main.rs:2:8
  |
2 | #[repr(C)]
  |        ^
3 | type A=u8;
  | ---------- not a struct, enum, or union

error[E0517]: attribute should be applied to struct or union
 --> src\main.rs:5:8
  |
5 | #[repr(packed)]
  |        ^^^^^^
6 | enum Foo{bar,baz}
  | ----------------- not a struct or union

error[E0517]: attribute should be applied to enum
 --> src\main.rs:8:8
  |
8 | #[repr(u8)]
  |        ^^
9 | struct S {bar: bool, baz: bool}
  | ------------------------------- not an enum

error[E0517]: attribute should be applied to struct, enum, or union
  --> src\main.rs:11:8
   |
11 | #[repr(C)]
   |        ^
12 | impl Foo {}
   | ----------- not a struct, enum, or union
```
describe:#[repr(...)]该属性置于不支持的类型上
> `#[repr(C)]` 只能放在结构体和枚举上
> `#[repr(packed)]`  `#[repr(simd)]` 只能放在结构体上
> `#[repr(u8)],#[repr(u16)]`,等属性只能放置在枚举上

这类属性不适用于typedef，因为typedef只是别名
>像＃[repr（u8）]，＃[repr（i64）]之类的表示用于为任何变体中没有数据字段的枚举选择区分大小。
>enum color{Red,Blue,Green},有效地将枚举的大小设置为提供的类型的大小。这样的枚举也可以转换为相同类型的值。

简而言之，`＃[repr（u8）]`使枚举的行为类似于具有一组受限制的允许值的整数。
只能将无字段的枚举强制转换为数值基元，因此此属性不适用于struct
`#[repr(packed)]` 减少填充以使结构体尺寸更小，**枚举的表示没有在Rust中严格定义，并且此属性不适用于枚举**
`#[repr(simd)]`将给出由一些列同类机器类型(u8,i32...),组成的结构，该结构允许同构SIMD进行矢量化
这对于枚举没有多大的意义，因为它们不包含单个数据列表。

### [E0518]
```rust
fn main() {}

#[inline(always)]
struct Doo;

#[inline(never)]
impl Doo {}
```
result:
```
error[E0518]: attribute should be applied to function or closure
 --> src\main.rs:3:1
  |
3 | #[inline(always)]
  | ^^^^^^^^^^^^^^^^^
4 | struct Doo;
  | ----------- not a function or closure

error[E0518]: attribute should be applied to function or closure
 --> src\main.rs:6:1
  |
6 | #[inline(never)]
  | ^^^^^^^^^^^^^^^^
7 | impl Doo {}
  | ----------- not a function or closure
```
describe:`#[inline(...)]`应用于闭包或函数
>`#[inline()]` 提示编译器是否尝试内联方法或函数。默认情况下，编译器会解决这个问题，
>若注释了`#[inline(always)]`,和`#[inline(never)]` 可以覆盖或强制执行编译器的决定。

注：如果希望将此属性应用于impl中的所有方法，需要手动注释每个方法。无法使用＃[inline]属性注释整个impl。

### [E0520]
```rust
#![feature(specialization)]
fn main() {}
trait T1{
    fn f1(&self);
}
impl<T>T1 for T{
    default fn f1(&self){}
}

impl <T:Clone> T1 for T{
    fn f1(&self){}
}

impl T1 for i32{
    deafult fn f1(&self){}
}
```
result:
```
error[E0520]: `f1` specializes an item from a parent `impl`, but that item is not mark
ed `default`
  --> src\main.rs:11:5
   |
6  | / impl<T>T1 for T{
7  | |     default f1(&self){}
8  | | }
   | |_- parent `impl` is here
...
11 |       fn f1(&self){}
   |       ^^^^^^^^^^^^^^ cannot specialize default item `f1`
   |
   = note: to specialize, `f1` in the parent `impl` must be marked `default`
```
describe:此类型已经实现了非默认实现，因此无法进一步进行专门化。
专业化仅允许您覆盖实现中的默认功能。
要解决此错误，需要将所有父实现标记为默认。例：
```rust
#![feature(specialization)]
fn main() {}
trait T1{
    fn f1(&self);
}
impl<T>T1 for T{
    default fn f1(&self){}
}

impl <T:Clone> T1 for T{
    default fn f1(&self){}
}

impl T1 for i32{
     fn f1(&self){}
}
```
### [E0522]
```rust
#![feature(lang_items)]

#[lang="cookie"]
fn f1()->!{
    loop {

    }
}
fn main() {}
```
result:
```
error[E0522]: definition of an unknown language item: `cookie`
 --> src\main.rs:3:1
  |
3 | #[lang="cookie"]
  | ^^^^^^^^^^^^^^^^ definition of unknown language item `cookie`
```
describe:lang 属性在无效的上下文中使用
>lang属性用于标记Rust内置的特殊项目，这包括影响编译器行为的特殊特征(如Copy Sized)
>以及可以自动调用的特殊功能，(对切片进行索引时越界访问的处理程序)

### [E0524]
```rust
fn f1(x:&mut isize){
    *x+=4;
}

fn f2(x:&mut isize){
    let mut c1=||f1(x);
    let mut c2=|| f1(x);
    c1();
    c2();
}
fn main() {}
```
result:
```
error[E0524]: two closures require unique access to `x` at the same time
 --> src\main.rs:7:16
  |
6 |     let mut c1=||f1(x);
  |                --   - first borrow occurs due to use of `x` in closure
  |                |
  |                first closure is constructed here
7 |     let mut c2=|| f1(x);
  |                ^^    - second borrow occurs due to use of `x` in closure
  |                |
  |                second closure is constructed here
8 |     c1();
  |     -- first borrow later used here
```
describe:需要多个变量，唯一访问的变量同时在多个闭包中使用
solution:若要在多个闭包中使用同一个变量，使用Rc(跨协程则是Arc)
```rust
use std::rc::Rc;
use std::cell::RefCell;
use std::borrow::BorrowMut;



fn set(x: &mut isize) {
    *x += 4;
}

fn dragoooon(x: &mut isize) {
    let x = Rc::new(RefCell::new(x));
    let y = Rc::clone(&x);
    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&mut x2); };
    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&mut x2); }; // ok!

    c2();
    c1();
}

fn main() {}
```
OR:只运行一次闭包
```rust
use std::rc::Rc;
use std::cell::RefCell;
use std::borrow::BorrowMut;

fn f1(x: &mut isize) {
    *x += 4;
}

fn f2(x: &mut isize) {
    {
        let mut c1 = || f1(x);
        c1();
    }

    let mut c2 = || f2(x);
    c2();
}

fn main() {}
```
### [E0525]
```rust
fn main() {
    let x=A;
    let c= |_|f1(x);
    f2(c);
}
struct A;
fn f1<T>(_:T){}

fn f2<T:Fn(u32)>(_:T){}
```
result:
```
error[E0525]: expected a closure that implements the `Fn` trait, but this closure only
 implements `FnOnce`
 --> src\main.rs:3:12
  |
3 |     let c= |_|f1(x);
  |            ^^^^^^-^
  |            |     |
  |            |     closure is `FnOnce` because it moves the variable `x` out of its
environment
  |            this closure implements `FnOnce`, not `Fn`
4 |     f2(c);
  |     -- the requirement to implement `Fn` derives from here
```
describe:预期实现了Fn特性的闭包，但此闭包仅实现了FnOnce
闭包为FnOnce闭包，而f2函数期望为Fn闭包。在这种情况下，
解决问题很简单，只需要在struct A上实现Copy和Clone特性即可，这可以：
```rust
fn main() {
    let x=A;
    let c= |_|f1(x);
    f2(c);
}
#[derive(Copy, Clone)]
struct A;
fn f1<T>(_:T){}

fn f2<T:Fn(u32)>(_:T){}
```
### [E0527]
```rust
fn main() {
    let r=&[1,2,3,4];
    match r {
        &[a,b]=>{
            println!("a={},b={}",a,b);
        }
    }
}
```
result：
```
E:\mytest_ru>cargo clippy
    Checking mytest_ru v0.1.0 (E:\mytest_ru)
error[E0527]: pattern requires 2 elements but array has 4
 --> src\main.rs:4:10
  |
4 |         &[a,b]=>{
  |          ^^^^^ expected 4 elements
```
describe:数组或切片模式中的元素数目与要匹配的数组中的元素不同
确保模式与匹配数组的大小一致。其他元素可以与`..`匹配
```rust
fn main() {
    let r=&[1,2,3,4];
    match r {
        &[a,b,..]=>{
            println!("a={},b={}",a,b);
        }
    }
}
```
### [E0528]
```rust
fn main() {
    let r=&[1,2];
    match r {
        &[a,b,c,res@ ..]=>{
            println!("a={},b={}",a,b);
        }
    }
}
```
result:
```
error[E0528]: pattern requires at least 3 elements but array has 2
 --> src\main.rs:4:10
  |
4 |         &[a,b,c,res@ ..]=>{
  |          ^^^^^^^^^^^^^^^ pattern cannot match array of 2 elements
```
describe:数组或切片模式比匹配数中需要的元素更多
确保匹配的数组至少包含与模式所需数量相同的元素。可以使用..匹配任意数量的剩余元素：
```rust
fn main() {
    let r=&[1,2];
    match r {
        &[a,res@ ..]=>{
            println!("a={},b={}",a,res[0]);
        }
    }
}
```
### [E0529]
```rust
fn main() {
    let r:f32=75.2;
    match r {
        [a,b]=>{
            println!("a={},b={}",a,b);
        }
    }
}
```
result:
```rust
error[E0529]: expected an array or slice, found `f32`
 --> src\main.rs:4:9
  |
4 |         [a,b]=>{
  |         ^^^^^ pattern cannot match with input type `f32`
```
describe:数组或切片模式与某些其他类型匹配
确保匹配的模式和表达式具有一致的类型
```rust
fn main() {
    let r:f32=75.2;
    match r {
        a=>{
            println!("a={}",a);
        }
    }
}
```
### [E0530]
```rust
fn main() {
    let r: (i32, i32) = (0, 0);
    match r {
        T => {}
    }
}

static T: i32 = 0;
```
result:
```
error[E0530]: match bindings cannot shadow statics
 --> src\main.rs:4:9
  |
4 |         T=>{
  |         ^ cannot be named the same as a static
...
9 | static T:i32=0;
  | --------------- the static `T` is defined here

```
describe:匹配绑定不能遮盖静态变量
fix：只需要更改绑定的名称即可避免遮盖其中一个
1、struct name；2、struct/eunm variant；3、static；4、const
5、assoicated const
```rust
fn main() {
    let r: (i32, i32) = (0, 0);
    match r {
        _kk => {}
    }
}

static _T: i32 = 0;
```
### [E0531]
```rust
fn main() {
    let type(x)=Type(12);
    match Bar(12) {
        Bar(x)=>{},
        _ => {}
    }
}
```
result:
```
error[E0531]: cannot find tuple struct or tuple variant `Bar` in this scope
 --> src\main.rs:4:9
  |
4 |         Bar(x)=>{},
  |         ^^^ not found in this scope


error[E0531]: cannot find tuple struct or tuple variant `r#type` in this scope
 --> src\main.rs:2:9
  |
2 |     let type(x)=Type(12);
  |         ^^^^ not found in this scope
```
describe:已使用未知的元组struct / variant。
```rust
fn main() {
    let Type(_x)=Type(12);
    use Foo::*;
    match Bar(12) {
        Bar(_x)=>{},
    }
}
1
struct Type(u32);

enum Foo{
    Bar(u32),
}
```
or:
```rust
struct Type(u32);

enum Foo {
    Bar(u32),
}
use Foo::*;

let Type(x) = Type(12); // ok!
match Type(12) {
    Type(x) => {} // ok!
    _ => {}
}
```
### [E0532]
```rust
enum State {
    Succeeded,
    Failed(String),
}

fn print_on_failure(state: &State) {
    match *state {   
        State::Failed => println!("Failed"),
        _ => ()
    }
}

fn main() {}
```
result:
```
error[E0532]: expected unit struct, unit variant or constant, found tuple variant `Sta
te::Failed`
  --> src\main.rs:10:9
   |
3  |     Failed(String),
   |     -------------- `State::Failed` defined here
...
10 |         State::Failed => println!("Failed"),
   |         ^^^^^^^^^^^^^ did you mean `State::Failed( /* fields */ )`?
```
describe:匹配项和预期种类不符合
确保匹配臂种类与被匹配的表达式相同
```rust
fn main() {}
enum A {
    X,
    Y(String),
}
fn f1(a: &A) {
    match *a {
        A::Y( ref hello)=> {
            println!("Y");
        }
        _ => {}
    }
}
```
### [E0533]
```rust
fn main() {
    match 0u32{
        A::f1=>{},
        _=>{},
    }
    if let A::f1=0u32{};
}

struct A;
impl A{
    fn f1(&self)->u32{1}
}
```
result:
```
error[E0533]: expected unit struct, unit variant or constant, found associated functio
n `A::f1`
 --> src\main.rs:3:9
  |
3 |         A::f1=>{},
  |         ^^^^^

error[E0533]: expected unit struct, unit variant or constant, found associated functio
n `A::f1`
 --> src\main.rs:6:12
  |
6 |     if let A::f1=0u32{};
  |            ^^^^^
```
describe:不是单元结构，变体或常量的项目已用作匹配模式。
若要匹配方法返回值，则需要绑定该值
```rust
fn main() {
    match 0u32{
        x if x==A.f1()=>{}, // 值绑定
        _=>{},
    }

}

struct A;
impl A{
    fn f1(&self)->u32{1}
}
```
### [E0534]
```rust
#[inline()]
pub fn f1(){}
fn main() {}
```
result:
```
error[E0534]: expected one argument
   --> src\main.rs:1:1
    |
  1 | #[inline()]
    | ^^^^^^^^^^^
```
describe:inline属性格式错误，带括号的inline属性其需要一个参数
```rust
#[inline(never)]
pub fn f1(){}
fn main() {}
```
此外，该属性五括号版可以用于提示编译器inline
#### [E0535]
```rust
#[inline(unknown)]
pub fn f1(){}
fn main() {}
```
result:
```
error[E0535]: invalid argument
 --> src\main.rs:1:10
  |
1 | #[inline(unknown)]
  |          ^^^^^^^
```
describe；inline属性中给定无效参数
**inline仅支持**：always以及 never参数，其余参数给定皆为错
### [E0536]
```rust
#[cfg(not()]
pub fn f1(){}
fn main() {}
```
result:
```rust
error[E0536]: expected 1 cfg-pattern
 --> src\main.rs:1:7
  |
1 | #[cfg(not()]
  |       ^^^^^
```
describe: cfg模式的格式错误
期望一个cfg模式
```rust
#[cfg(not(target_os="windows"))]
pub fn f1(){}
fn main() {}
```
### [E0537]
```rust
#[cfg(unknown())]
pub fn f1(){}
fn main() {}
```
cfg属性使用了未知的属性
**cfg**属性支持的参数:any; all; not
### [E0538]
```rust
#[deprecated(
since = "1.0.0",
note = "First deprecation note.",
note = "Second deprecation note."
)]
fn main() {}
```
result:
```
error[E0538]: multiple 'note' items
 --> src\main.rs:4:1
  |
4 | note = "Second deprecation note."
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```
describe:属性包含同一元项目不止一次
>元项目时属性内部的键/值对，每个键值对只能在每个属性中使用一次

fix：使用相同的键删除除元数据项之外的所有元数据项
```rust
#[deprecated(
since = "1.0.0",
note = "First deprecation note.",
)]
fn main() {}
```
### [E0541]
```rust
#[deprecated(
since="1.0.0",
reason="Example invalid meta item. Should be 'note'")
]
fn main() {}
```
result:
```
error[E0541]: unknown meta item 'reason'
 --> src\main.rs:3:1
  |
3 | reason="Example invalid meta item. Should be 'note'")
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected one of `since`, `not
e`
```
describe:属性使用了无效的元项目
>元项目是属性内部的键/值对。提供的键必须是指定属性的有效键之一。

fix:删除未知的元项目，如提供的名称错误，则将其重命名
```rust
#[deprecated(
since="1.0.0",
note="This is a valid meta item for the deprecated attribute.")
]
fn main() {}
```
### [E0550]
```rust
#[deprecated(note = "because why not?")]
#[deprecated(note = "right?")]
fn main() {}
```
result:
```
error[E0550]: multiple deprecated attributes
 --> src\main.rs:3:1
  |
3 | fn main() {}
  | ^^^^^^^^^^^^
```
describe:单个项目中多次使用不推荐的属性
不推荐使用的属性只能在一个项目上出现一次
### [E0551]
```rust
#[deprecated(note)]
fn main() {}
```
result:
```
error[E0551]: incorrect meta item
 --> src\main.rs:1:14
  |
1 | #[deprecated(note)]
  |              ^^^^

```
describe:属性内使用了无效的元项目
元项目是属性内部的键值对
fix:为注释键赋予一个值

### [E0552]
```rust
#[repr(D)]
struct A{
    a:usize,
}
fn main() {}
```
result:
```
error[E0552]: unrecognized representation hint
 --> src\main.rs:1:8
  |
1 | #[repr(D)]
  |        ^
```
describe:无法识别的标识提示
>使用repr属性告诉编译器如何将结构体或者枚举布局在内存之中

确保使用的是受支持的选项之一：
```rust
#[repr(C)]
struct A{
    a:usize,
}
fn main() {}
```
### [E0554]
**554-557  稳定版不建议作死尝试**
```rust
#![feature(non_ascii_idents)]

fn main() {}
```
result:
```
error[E0554]: `#![feature]` may not be used on the stable release channel
 --> src\main.rs:1:1
  |
1 | #![feature(non_ascii_idents)]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```
describe:#![feature]不能再稳定发行版本上使用
>如果需要此功能，请确保使用每晚发布的编译器（但请注意，将来可能会删除或更改该功能）

### [E0556]
```rust
#![feature(foo_bar_baz, foo(bar), foo = "baz", foo)] // error!
#![feature] // error!
#![feature = "foo"] // error!
```
describe:feature格式错误
feature属性仅接收"flag",并且只能再不稳定版本中使用
### [E0557]
```rust
#![feature(managed_boxes)]
```
describe:feature的属性已经被删除
### [E0559]
```rust
enum AP{
    A{x:u32},
}

fn main() {
    let a=AP::A {jack:0};
}
```
result:
```
error[E0559]: variant `AP::A` has no field named `jack`
 --> src\main.rs:6:18
  |
6 |     let a=AP::A {jack:0};
  |                  ^^^^ `AP::A` does not have this field
  |
  = note: available fields are: `x`
```
describe:枚举的结构变量中指定了一个未知字段

### [E0560]
```rust
struct  AP{
    a:i32
}

fn main() {
    let a =AP{a:22,b:22};
}
```
result:
```
error[E0560]: struct `AP` has no field named `b`
 --> src\main.rs:6:20
  |
6 |     let a =AP{a:22,b:22};
  |                    ^ `AP` does not have this field
  |
  = note: available fields are: `a`
```
describe:结构体中未知的字段
### [E0561]
```rust
fn main() {
    type A=fn(mut a:u8);
    type B=fn(&a:u32);
}
```
result:
```
error[E0561]: patterns aren't allowed in function pointer types
 --> src\main.rs:4:15
  |
4 |     type B=fn(&a:u32);
  |               ^^
```
describe:非标识符或通配符模式以用作功能指针类型的参数
函数指针类型中不允许使用模式,
**在函数类型上使用别名时，不能将参数表示为可变参数。**
fix: 删除模式,或者使用_
```rust

fn main() {
    type A=fn(a:u8);
    type B=fn(_:u32);
}
```
或省略参数名称
```rust

fn main() {
    type A=fn(u8);
    type B=fn(u32);
}
```
### [E0562]
```rust

fn main() {
    let x:impl Iterator<Item=usize>=0..10;
    for i in x{
        println!("{}",i);
    }
}
```
result:
```
error[E0562]: `impl Trait` not allowed outside of function and inherent method return
types
 --> src\main.rs:3:11
  |
3 |     let x:impl Iterator<Item=usize>=0..10;
  |           ^^^^^^^^^^^^^^^^^^^^^^^^^
```
describe:impl在函数和固有方法返回类型之外不允许Trait
**抽象返回类型(为某些trait编写的impl trait)仅允许作为函数和固有的impl返回类型**
确保impl trait仅出现在返回类型的位置.
```rust
fn main() {
    for i in f1(10) {
        println!("{}", i);
    }
}

fn f1(n: usize) -> impl Iterator<Item=usize> {
    0..n
}
```
### [E0565]
```rust
#[repr("C")]
struct Repr{}
fn main() {}
```
result:
```
error[E0565]: meta item in `repr` must be an identifier
 --> src\main.rs:1:8
  |
1 | #[repr("C")]
  |        ^^^
```
describe:repr中的meta项必须是一个标识符
在不支持文字的内置属性中使用了文字
>属性中的文字是新属性，内置属性在很大程度上不受支持。努力在适当的地方支持文字。尝试改用无引号的名称
>
### [E0566]
```rust
#[repr(u32,u64)]
enum Repr{}
fn main() {}
```
result:
```
error[E0566]: conflicting representation hints
 --> src\main.rs:1:8
  |
1 | #[repr(u32,u64)]
  |        ^^^ ^^^
  |
  = note: `#[deny(conflicting_repr_hints)]` on by default
```
describe:在同一项目上使用了相互矛盾的提示
*大多数情况下,仅使用一个标识提示足矣*
如果要根据当前体系结构使用标识形式提示,可以使用`cfg_attr`
```rust
#[cfg_attr(windows, repr(u32))]
enum Repr { A(i8) }

fn main() {}
```
### [E0567]
```rust
#![feature(optin_builtin_traits)]

auto trait Generic<T> {}
fn main() {}
```
result:
```
error[E0567]: auto traits cannot have generic parameters
 --> src\main.rs:3:19
  |
3 | auto trait Generic<T> {}
  |            -------^^^ help: remove the parameters
  |            |
  |            auto trait cannot have generic parameters
```
describe:auto trait 不能有泛型参数
>由于对所有现有类型都实现了自动特征，因此编译器将无法推断特征的通用参数的类型。

fix:
```rust
#![feature(optin_builtin_traits)]

auto trait Generic {}

fn main() {}
```
### [E0568]
```rust
#![feature(optin_builtin_traits)]

auto trait Generic:Copy {}

fn main() {}
```
result:
```
error[E0568]: auto traits cannot have super traits
 --> src\main.rs:3:20
  |
3 | auto trait Generic:Copy {}
  |            ------- ^^^^ help: remove the super traits
  |            |
  |            auto trait cannot have super traits
```
describe:auto triat 不能继承其他的trait
>由于对所有现有类型都实现了auto trait，因此添加supr trait将过滤掉许多这些类型。

几乎所有现有类型都不能实现Generic，因为它们中只有极少数具有Copy特性。
fix: 移除supr trait
### [E0569]
```rust
#![feature(drop_eyepatch)]

struct A<X>(X);

fn main() {}

impl<#[may_dangle] X> Drop for A<X> {
    fn drop(&mut self) {}
}
```
result:
```
error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute
 --> src\main.rs:6:1
  |
6 | / impl <#[may_dangle] X> Drop for A<X>{
7 | |     fn drop(&mut self){}
8 | | }
  | |_^
```
describe:如果impl具有带有＃[may_dangle]属性的通用参数，则必须将该impl声明为不安全的impl。
>本例中,断言A的析构函数将不访问任何类型X的数据,
>并且要求此断言对我们程序的整体安全性为true。编译器当前不尝试验证此断言。
>因此，我们必须将此隐式标签标记为不安全

### [E0570]
当前目标不支持所请求的ABI.Rust编译器为每个目标维护该目标上不支持的ABI的列表.
如果这样的列表中存在ABI，这通常意味着llvm当前不支持目标/ ABI组合。
如有必要，可以使用自定义目标规范来规避此检查。
### [E0571]
```rust
fn main() {
    let res = while true {
        if satisfied(i) {
            break 2 * i;
        }
        i += 1;
    };
}
```
result:
```
error[E0571]: `break` with value from a `while` loop
 --> src\main.rs:4:13
  |
4 |             break 2 * i;
  |             ^^^^^^^^^^^ can only break with a value inside `loop` or breakable blo
ck
  |
help: instead, use `break` on its own without a value inside this `while` loop
  |
4 |             break;
  |             ^^^^^
```
describe:带参数的break语句出现在非循环循环中。
fix:单独使用`break`而不在`while`循环中使用值。
>break 语句可以loop循环中使用一个参数(如果执行break语句,则为循环表达式的值),但不能用于let循环
>while 循环或while let 循环

```
fn main() {
    let res = loop {
        if satisfied(i) {
            break 2 * i;
        }
        i += 1;
    };
}
```
### [E0572]
````rust
fn main() {}
const A:u32=return 0;
````
result:
```
error[E0572]: return statement outside of function body
 --> src\main.rs:2:13
  |
2 | const A:u32=return 0;
  |             ^^^^^^^^
```
describe:return 出现在函数体之外
fix:删除return 或者将return移进函数体内
### [E0573]
```rust
fn main() {}
enum A {
    JAck,
}
fn f1() -> A::JAck {
    A::JAck
}
const CONST_VAL: u32 = 2;
impl CONST_VAL {}

enum B {
    C,
    D,
}
trait T {
    fn f2(_: B::D);
}
```
result:
```
error[E0573]: expected type, found variant `A::JAck`
 --> src\main.rs:5:12
  |
5 | fn f1() -> A::JAck {
  |            ^^^^^^^
  |            |
  |            not a type
  |            help: try using the variant's enum: `crate::A`

error[E0573]: expected type, found constant `CONST_VAL`
 --> src\main.rs:9:6
  |
9 | impl CONST_VAL {}
  |      ^^^^^^^^^ not a type

error[E0573]: expected type, found variant `B::D`
  --> src\main.rs:16:14
   |
16 |     fn f2(_: B::D);
   |              ^^^^
   |              |
   |              not a type
   |              help: try using the variant's enum: `crate::B`
```
describe:预期使用某种类型之外的其他东西
在所有这些错误中，应该使用一种类型
```rust
fn main() {}

enum A {
    JAck,
}

fn f1() -> A {
    A::JAck
}

// 不能在项目上实现某些东西，而只能在类型上实现,创建一个新的类型
struct val(u32);

const CONST_VAL: val = val(2);

impl val {}

enum B {
    C,
    D,
}

// 使用模式匹配从而将枚举的变体引入函数内部
trait T {
    fn f2(b: B) {
        match b {
            B::C => {}
            B::D => {}
        }
    }
}
```
### [E0574]
```rust
fn main() {
    let a=A{x:()};

    let b=B::S{i:7};
    match b{
        B{i}=>{},
    }
}
mod A{}

enum B{
    S{i:isize}
}
```
result:
```
error[E0574]: expected struct, variant or union type, found enum `A`
 --> src\main.rs:2:11
  |
2 |     let a=A{x:()};
  |           ^ not a struct, variant or union type

error[E0574]: expected struct, variant or union type, found enum `B`
 --> src\main.rs:6:9
  |
6 |         B{i}=>{},
  |         ^ not a struct, variant or union type
```
describe:预期使用struct,变体或联合以外的其他东西。
```rust
mod A{
    pub struct SA{
        pub x:usize
    }
}
fn main() {
    let a=A::SA{x:1};

    let b=B::S{i:7};
    match b{
        B::S{i}=>{},
    }
}


enum B{
    S{i:isize}
}
```
### [E0575]
```rust
fn main() {
    let _: <u8 as A>::M;
    let _: <u8 as T1>::fm;
}

enum A { M }

trait T1 {
    type E;
    fn fm() {}
}

impl T1 for u8 {
    type E = u16;
}
```
result:
```
error[E0575]: expected associated type, found variant `A::M`
 --> src\main.rs:2:12
  |
2 |     let _: <u8 as A>::M;
  |            ^^^^^^^^^^^^ not a associated type

error[E0575]: expected associated type, found associated function `T1::fm`
 --> src\main.rs:3:11
  |
3 |     let _:<u8 as T1>::fm;
  |           ^^^^^^^^^^^^^^ not a associated type
```
describe:给定出类型或关联类型之外的其余内容
> let _: <u8 as A>::M;   let _:<u8 as T1>::fm;
>二者并不是关联类型所以编译器无法预判
```rust
fn main() {
    let _:A;
    let _:<u8 as T1>::E;
}

enum A { M }

trait T1 {
    type E;
    fn fm() {}
}

impl T1 for u8 {
    type E = u16;
}
```

### [E0576]
```rust
fn main() {}
trait T1 {
    type E;
    fn fm() -> <Self as T1>::KK {}
}
```
result:
```
error[E0576]: cannot find associated type `KK` in trait `T1`
 --> src\main.rs:4:30
  |
4 |     fn fm() -> <Self as T1>::KK {}
  |                              ^^ not found in `T1`
```
describe:未定的关联类型
```rust
fn main() {}
trait T1 {
    type E;
    fn fm() -> <Self as T1>::E {}
}
```
### [E0577]
```rust
fn main() {}
pub struct S;
pub (in crate::S)struct KK;
```
result:
```
error[E0577]: expected module, found struct `crate::S`
 --> src\main.rs:3:9
  |
3 | pub (in crate::S)struct KK;
  |         ^^^^^^^^ not a module
```
describe:在可见性范围中发现了模块以外的其他东西
>S 不是模块,因此在可见的路径中使用其是无效的

fix:保持S是一个模块
```rust
fn main() {}
pub mod  S {
    pub(in crate::S) struct KK;
}
```
### [E0578]
```rust
fn main() {}
foo!();
pub (in ::S)struct LL;
```
result:
```
error[E0578]: cannot determine resolution for the visibility
 --> src\main.rs:3:9
  |
3 | pub (in ::S)struct LL;
  |         ^^^
```
describe:找不到模块,
由于多foo!()的调用,编译器猜测缺少的模块可能在其中,并且由于找不到宏定义而失败
fix:确保模块在范围内
```rust
fn main() {}

mod S {
    pub(in crate::S) struct LL;
}
```
### [E0579]
```rust
#![feature(exclusive_range_pattern)]

fn main() {
    match 5u32 {
        // This range is ok, albeit pointless.
        1 .. 2 => {}
        // This range is empty, and the compiler can tell.
        5 .. 5 => {} // error!
    }
}
```
describe:较低范围不小于较高范围
范围匹配时,编译器会验证该范围是否为非空的,包括起点,但不包括终点,此等效于要求范围的起点小于范围的终点.
### [E0580]
```rust
fn main(x:u32) {
    println!("{}",x);
}
```
result:
```
error[E0580]: `main` function has wrong type
 --> src\main.rs:1:1
  |
1 | fn main(x:u32) {
  | ^^^^^^^^^^^^^^ incorrect number of function parameters
  |
  = note: expected fn pointer `fn()`
             found fn pointer `fn(u32)`
```
describe:main函数被错误的调用(无参的发散函数)
### [E0581]
```rust
fn main() {
    let x:for<'a> fn()->&'a i32;
}
```
result:
```
error[E0581]: return type references lifetime `'a`, which is not constrained by the fn
 input types
 --> src\main.rs:2:25
  |
2 |     let x:for<'a> fn()->&'a i32;
  |                         ^^^^^^^
```
describe:fn类型中,生存期仅出现在返回值类型中,而不出现在参数类型中
>此处的问题时生命周期不是任何论点的额结束,因此无法确定声明中期,

fix:在参数中使用生命周期,或者使用静态生命周期
```rust
fn main() {
    let x: fn()->&'static i32;
    let y:for<'a>fn(&'a i32)->&'a i32;
}
```
### [E0582]
```rust
fn main() {}
fn f1<F>(t:F)
where F:for <'a>Fn(i32)->Option<&'a i32>
{

}
```
result:
```
error[E0582]: binding for associated type `Output` references lifetime `'a`, which doe
s not appear in the trait input types
 --> src\main.rs:3:26
  |
3 | where F:for <'a>Fn(i32)->Option<&'a i32>
  |                          ^^^^^^^^^^^^^^^
```
describe:对关联类型“Output”的绑定引用了生命周期“ a”，但不会出现在特征输入类型中
fix在输入中使用'static生命周期
```rust
fn main() {}

fn f1<F, Q>(t: F, u: Q)
    where
        F: for<'a> Fn(&'a i32) -> Option<&'a i32>,
        Q: Fn(i32) -> Option<&'static i32>
{}
```
### [E0583]
```rust
fn main() {}

mod file_that_doesnt_exixt;
```
result:
```
error[E0583]: file not found for module `file_that_doesnt_exixt`
 --> src\main.rs:3:1
  |
3 | mod file_that_doesnt_exixt;
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `file_that_doesnt_exixt`, create file "src\file_that_do
esnt_exixt.rs"
```
describe:找不到离线得模块文件
>请确保存在与模块相对应的文件。如果要使用名为file_that_doesnt_exist的模块，
>则需要在同一目录中有一个名为file_that_doesnt_exist.rs或file_that_doesnt_exist / mod.rs的文件。

### [E0584]
```rust
fn main() {}
trait T{
    fn f1();
    /// i'm f1
}
```
result:
```
error[E0584]: found a documentation comment that doesn't document anything
 --> src\main.rs:4:5
  |
4 |     /// i'm f1
  |     ^^^^^^^^^^ this doc comment doesn't document anything
  |
  = help: doc comments must come before what they document, maybe a comment was intend
ed with `//`?
```
describe:发现没有任何内容的文档注释
注: doc注释必须放置在应记录的项目之前,因此如果要记录 trait 则需要在其之前添加注释,而不是在其内部天键文档注释
方法也是如此:doc注释必须放在其前
```rust
fn main() {}

/// i'm T
trait T {
    /// i'm f1
    fn f1();
}
```
### [E0585]
```rust
fn main() {
    // main method
    /// this is a unless doc  comment
}
```
result:
```
error[E0585]: found a documentation comment that doesn't document anything
 --> src\main.rs:3:5
  |
3 |     /// this is a unless doc  comment
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: doc comments must come before what they document, maybe a comment was intend
ed with `//`?
```
describe:找到了没有任何内容的文档注释
文档注释后面必须有项目，包括功能，类型，模块等
### [E0586]
```rust
fn main() {
    let tmp=vec![0,1,2,3,4,3,3,2,2,1];
    let _x=&tmp[1..=];
}
```
result:
```
error[E0586]: inclusive range with no end
 --> src\main.rs:3:18
  |
3 |     let _x=&tmp[1..=];
  |                  ^^^ help: use `..` instead
  |
  = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)
```
describe:使用的范围无限
>包含范围需要包含该范围的结尾,若只需要起点而不是终点,请使用非包含范围
>或者结束包含的范围

```rust
fn main() {
    let tmp=vec![0,1,2,3,4,3,3,2,2,1];
    let _x=&tmp[1..=5];
    let _y=&tmp[1..];
}
```
### [E0587]
```rust
#[repr(packed,align(8))]
struct A(i32);
fn main() {}
```
result:
```
E:\mytest_ru>cargo check
    Checking mytest_ru v0.1.0 (E:\mytest_ru)
error[E0587]: type has conflicting packed and align representation hints
 --> src\main.rs:2:1
  |
2 | struct A(i32);
  | ^^^^^^^^^^^^^^
```
describe:类型具有相互冲突的packed和align表示形式提示
>不能再同一类型上使用packed和align提示,如要将类型打包给定的大小,则应该提供打包的大小
```rust
#[repr(packed)]
struct A(i32);
fn main() {}
```
#### [E0588]
```rust
#[repr(align(16))]
struct Aligned(i32);

#[repr(packed)] // error!
struct Packed(Aligned);
fn main() {}
```
result
```
E:\mytest_ru>cargo check
    Checking mytest_ru v0.1.0 (E:\mytest_ru)
error[E0588]: packed type cannot transitively contain a `#[repr(align)]` type
 --> src\main.rs:5:1
  |
5 | struct Packed(Aligned);
  | ^^^^^^^^^^^^^^^^^^^^^^^
  |
note: `Aligned` has a `#[repr(align)]` attribute
 --> src\main.rs:2:1
  |
2 | struct Aligned(i32);
  | ^^^^^^^^^^^^^^^^^^^^
```
describe:packed属性提示的类型的字段带有align表示形式提示
>类似于不能再同一类型上同时具有align和packed表示形式提示一般,
>packed类型也不能包含带有align形式
>提示的另一个类型,但是可以执行相反的操作

```rust
#[repr(align(16))]
struct Aligned(Packed);

#[repr(packed)] // error!
struct Packed(i32);
fn main() {}
```
### [E0589]
```rust
#[repr(align(15))]
enum A{
    B(u64)
}
fn main() {}
```
result:
```
error[E0589]: invalid `repr(align)` attribute: not a power of two
 --> src\main.rs:1:8
  |
1 | #[repr(align(15))]
  |        ^^^^^^^^^
```
describe:无效的align参数(其参非2的幂)   2 ^ 29
### [E0590]
```rust
fn main() {
    while break {};
}
```
result:
```
error[E0590]: `break` or `continue` with no label in the condition of a `while` loop
 --> src\main.rs:2:11
  |
2 |     while break {};
  |           ^^^^^ unlabeled `break` in the condition of a `while` loop
```
describe:在没有标签的while循环中使用了break或Continue关键字
>在while循环中使用时,break和continue必须包含标签,

fix:添加一个标签来指定跳出那个循环
```rust
fn main() {
    'q:while break 'q {};
}
```
### [E0591]
```rust
let x:fn(S)=foo;
```
>fn（S）类型不是特定于任何特定函数的：
>它是一个函数指针。因此，调用x（）会导致虚拟调用，
>而foo（）是静态调度的，因为foo的类型精确地告诉我们正在调用什么函数。
>

>transmute用于转换fn参数的类型。这种模式是不正确的，因为因为foo的类型是一个零大小的函数项（typeof（foo）），而目标类型（fn（））是一个非零大小的函数指针。此模式应重写。有几种可能的方法：更改原始的fn声明以匹配期望的签名，并在调用transmute之前在fn主体中进行强制转换（首选选项）强制转换fn指针的fn项
>
注:尽管这种类型的使用通常是不正确的。目的通常是描述一个函数指针，但是仅使用fn（）就可以满足要求。 * mut fn（）是指向fn指针的指针
### [E0592]
```rust
fn main() {
    let x: fn(S) = foo;
}

struct A;

impl A {
    fn f1() {}
}

impl A {
    fn f1() {}
    fn f2() {}
}
```
result:
```
error[E0592]: duplicate definitions with name `f1`
  --> src\main.rs:7:4
   |
7  |    fn f1(){}
   |    ^^^^^^^^^ duplicate definitions for `f1`
...
11 |     fn f1(){}
   |     --------- other definition for `f1`
```
describe:使用相同的名称定义方法或关联函数
类似的错误是E0201。区别在于是否有一个声明块。为避免此错误，必须为每个fn赋予唯一的名称。
```rust
fn main() {}

struct A;

impl A {
    fn f1() {}
}

impl A {
    fn f2() {}
}
```
### [E0593]
```rust
fn main() {
    foo(|y|{});
}

fn foo<F:Fn()>(x:F){

}
```
result:
```
error[E0593]: closure is expected to take 0 arguments, but it takes 1 argument
 --> src\main.rs:2:5
  |
2 |     foo(|y|{});
  |     ^^^ --- takes 1 argument
  |     |
  |     expected closure that takes 0 arguments
```
describe:期望闭包采用0个参数，但采用1个参数;提供一个基于Fn的类型，其参数个数超出预期。
>必须提供基于Fn类型相同的数量的参数

fix:删除参数y
```rust
fn main() {
    foo(|| {});
}

fn foo<F: Fn()>(_x: F) {}
```
### [E0594]
```rust
fn main() {
    let s = A { e: 7 };
    s.e = 2;
}

struct A {
    e: i32
}
```
result:
```
error[E0594]: cannot assign to `s.e`, as `s` is not declared as mutable
 --> src\main.rs:3:5
  |
2 |     let s =A{e:7};
  |         - help: consider changing this to be mutable: `mut s`
3 |     s.e=2;
  |     ^^^^^ cannot assign
```
describe:试图修改不可变的值
```rust
fn main() {
    let mut s = A { e: 7 };
    s.e = 2;
}

struct A {
    e: i32
}
```
### [E0595]
注:此错误不在提示
```rust
fn main() {
    let x = 3;
    let mut c = || { x += 1 };
}
```
describe:闭包不能使用不可变的捕获变量发生冲突
fix:使变量绑定为可变
### [E0596]
```rust
fn main() {
    let  x = 3;
    let y=&mut x;
}
```
result:
```
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --> src\main.rs:3:11
  |
2 |     let  x = 3;
  |          - help: consider changing this to be mutable: `mut x`
3 |     let y=&mut x;
  |           ^^^^^^ cannot borrow as mutable
```
describe:可变地借用了一个非可变变量。
fix:声明被借用的变量为可变的
### [E0597]
```rust
fn main() {
    let mut x=A{x:None};
    {
        let y=0;
        x.x=Some(&y);
    }
    println!("{:?}",x.x);
}

struct A<'a>{
    x:Option<&'a u32>
}
```
result:
```
error[E0597]: `y` does not live long enough
 --> src\main.rs:5:18
  |
5 |         x.x=Some(&y);
  |                  ^^ borrowed value does not live long enough
6 |     }
  |     - `y` dropped here while still borrowed
7 |     println!("{:?}",x.x);
  |                     --- borrow later used here
```
describe:值仍在借用时被丢弃了
>在这里，y在内部作用域的末尾删除，但x借用它直到println。
>要修复前面的示例，只需删除范围，以便在println之后才删除y

### [E0599]
```rust
fn main() {
    let a=A;
    a.f1();
}
struct A;
```
result:
```
error[E0599]: no method named `f1` found for struct `A` in the current scope
 --> src\main.rs:3:7
  |
3 |     a.f1();
  |       ^^ method not found in `A`
4 | }
5 | struct A;
  | --------- method `f1` not found for this

```
describe:在未实现该方法的类型上使用方法
```rust
fn main() {
    let a=A;
    a.f1();
}
struct A;
impl A{
    fn f1(self){}
}
```
