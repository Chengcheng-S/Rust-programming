# std::rc

单线程引用计数

类型`Rc<T>` 提供在堆分配的T类型值得共享所有权，在Rc上调用`Clone`会生成一个**指向堆中相同分配得新指针**。当指向给定分配的最后一个Rc指针被破坏时，存储在该分配中的值(通常称为`内部值`)也会被删除。

默认情况下，Rust中的共享引用不允许可变，Rc也不例外，通常无法获得对Rc内部某个事物的可变引用。如果需要可变性，将**Cell或RefCell放在Rc中**

Rc使用非原子参考计数，即开销非常低，但是不能在线程之间发送Rc, 因此Rc不实现Send。

当编译器在线程之间发送检查时，结果将不会被编译。如果需要多线程、原子引用计数，使用`sync:：Arc`。

> `downgrade`方法可用于**创建非拥有**的`Weak`指针。弱指针可以升级到Rc，但是如果分配中存储的值已经被删除，那么它将返回None。换句话说，**弱指针不会使分配内的值保持活动状态；但是，它们确实使分配（内部值的后备存储）保持活动状态。**
>
> Rc指针之间的循环永远不会被释放。因此，`Weak`被用来打破`cycles` 
>
> 如：树可以有从父节点到子节点的强Rc指针，从子节点到父节点的弱Rc指针。
>
> Rc<T> 自动取消对T的引用(通过Deref trait)， 因此可以对Rc<T>类型的调用T的方法。为了避免与T方法的名称冲突，Rc<T>的方法本身是相关联的函数。

> 弱引用 Weak(T):
>
> - 通过`Rc::downgrade`传递实例的引用 ，调用该方法会的带Weak(T)类型的智能指针，同时将weak_count +1
> - 区别在于weak_count无需为0就能使Rc实例被清理，只要strong_count为0就可以了。
> - 可以通过Rc::upgrade方法返回Option<Rc<T>>对象。
>
> 所有强指针都有一个隐式的弱指针，确保强析构函数运行时，弱析构函数永远不会释放，即使弱指针存储在强指针内部也是如此。

```rust
use std::rc::Rc;
let my_rc=Rc::new(());

Rc::dowgrade(&my_rc)
```

Weak<T> 不会自动解引用T，因为其内部值可能已被删除。

### clone reference 

使用为Rc和Weak实现的clone特征，创建与现有引用计数指针相同的分配的新引用。

```rust
use std::rc::Rc;
let foo = Rc::new(vec![1.0, 2.0, 3.0]);
// The two syntaxes below are equivalent.
let a = foo.clone();
let b = Rc::clone(&foo);
```

`Rc::clone(&from)`  最常用的，因为其更明确地传达了代码的含义，

### structs

| Rc   | 一个单线程引用计数指针Rc'代表“参考计数”。                    |
| ---- | ------------------------------------------------------------ |
| Weak | Weak是Rc的一个版本，它持有对托管分配的非拥有引用。通过对弱指针调用`upgrade`来访问分配，它返回一个Option<Rc<T>> |

