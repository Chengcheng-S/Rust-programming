# std::ptr

通过原始指针手动管理内存

## Safety

此模块中的许多函数将原始指针作为参数，并对其进行读写操作。为了安全起见，这些**指针必须有效**。指针是否有效取决于指针用于的操作（读或写），以及访问的内存范围（即读/写的字节数）。大多数函数使用 `*mut T`和`const T`只访问一个值，在这种情况下，文档会忽略该大小，并隐式地假定`size_of::<T>()` 字节

有效性的规则尚未明确，官方给出的几种情况：

- 空指针永远无效，即使对于大小为零的访问也是如此
- 除空指针之外的其余指针，对大小为零的所有操作都有效
- 在一个指针的起实范围内，一个指针必须是有效的，但不能总在一个指针范围内被分配，   注：**Rust中，每个(堆栈分配的)变量都被视为一个单独的已经分配的对象**
- 从用于在线程之间同步的原子操作的意义上讲，此模块中的函数执行的所有访问都是**非原子的**。 从不同的线程对同一位置执行两次并发访问是未定义的行为，除非两次访问都只从内存读取。注： 这显式包括read_volatile和write_volatile：volatile访问不能用于线程间同步。
- 只要底层对象处于**活跃状态并且不使用引用**（**仅原始指针**）来访问同一内存，则对指针的引用强制转换的结果就有效。

### Alignment

有效原始指针不一定正确对齐（其中“正确”对齐由指针对象类型定义，即，*const T必须与mem:：align_of:：<T>（））对齐。

当一个函数需要正确的对齐时，即使访问的大小为0，也就是说，即使内存实际上没有被触动。在这种情况下，使用`NonNull:：dangling`。

### Structs

NonNull      `*mut T`  非零和协变

### Macros

均属于试验阶段：

| raw_const | 创建指向某个位置的const raw指针，而不创建中间引用。 |
| --------- | --------------------------------------------------- |
| raw_mut   | 创建指向一个地方的mut raw指针，而不创建中间引用。   |

### Functions

| copy                     | 将`counut *size_of::<T>()` 字节从`src` copy 到`dst`,源和目标可叠加 |
| ------------------------ | ------------------------------------------------------------ |
| copy_nonoverlapping      | 将`counut *size_of::<T>()` 字节从`src` copy 到`dst`,源和目标不可叠加 |
| drop_in_place            | (存在)执行指向值得析构函数                                   |
| eq                       | 比较原始指针是否相等                                         |
| hash                     | hash 原始指针                                                |
| null                     | 创建 null 的原始指针                                         |
| null_mut                 | 创建null的可变原始指针                                       |
| read                     | 从src读取值而不移动它。这使src中的内存保持不变。             |
| read_unaligned           | 从src读取值而不移动它。这使src中的内存保持不变。             |
| read_volatile            | 从src执行不稳定的值读取，而不移动它。这使src中的内存保持不变。 |
| replace                  | 将src移到指定的dst中，返回以前的dst值。                      |
| slice_from_raw_parts     | 从指针和长度形成原始切片                                     |
| slice_from_raw_parts_mut | 除了返回原始可变切片而不是原始不可变切片外，执行的功能与“原始不可变切片”相同。 |
| swap                     | 交换同一类型的两个可变位置的值，而无需取消初始化。           |
| swap_nonoverlappinig     | 在从x和y开始的两个内存区域之间交换`count*size_:：<T>（）`字节。这两个区域不能重叠。 |
| write                    | 使用给定值重写内存位置，而不读取或删除旧值                   |
| write_bytes              | 将从dst开始的`count*size_of:：<T>（）`字节的内存设置为val    |
| write_unaligned          | 使用给定值重写内存位置，而不读取或删除旧值                   |
| write_volatile           | 使用给定值对内存位置执行易失性写入，而不读取或删除旧值       |

