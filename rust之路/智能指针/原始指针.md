## 原始指针

> 原始指针是一个没有 Rust 标准保证的内存地址。 这些本质上是不安全的。 例如，与引用 (&T) 不同，原始指针可以为空。原始指针分别表示为 *const T 和 *mut T 表示不可变和可变原始指针。 尽管每个都是单一类型，但它们包含三个标记：*、const 或 mut。   Rust 引用（&mut T 和 &T）编译成原始指针。 这意味着可以访问原始指针的性能而无需冒险进入不安全的块。   



```rust
fn  main(){
    let a: i64 = 42;
    let a_ptr = &a as *const i64;
    
    println!("a:{} {:p}",a,a_ptr);
}
```

Rust 的指针类型 *const T 和 *mut T 总是指向 T 的起始字节，它们也知道类型 T 的字节宽度。 内存地址可能是指内存中的任何地方。

通过 std::mem::transmute 将对其的引用转换为原始指针来获取值的地址。 

TIP:  原始指针(raw pointers) 并不是安全的, 原始指针通常由操作系统或第三方库在 Rust 代码中处理。



```rust
fn main(){
	 /*
    将一种类型的值 重新解释为另一种类型，  两种类型必须具有相同的大小，原始值和结果都不能是无效值，
    transmute在语义上等同于将一种类型按位移动到另一种类型。 它将源值中的位复制到目标值中，然后忘记原始值。 它在memcpy相当于 C 的memcpy ，就像transmute_copy一样
    用途：
        -  延长生命周期，或者缩短不可变生命周期
        -  将指针转换为其他类型的指针
     */
    let a_addr: usize = unsafe {
        std::mem::transmute(a_ptr)
    };

    println!("a:{} {:p}   0X:{:x}", a, a_ptr, a_addr + 7);


    let prt = 42 as *const Vec<String>;

    unsafe {
        let new_addr = prt.offset(4);
        println!("{:p}====> {:p}", prt, new_addr);
    }
}
```

原始指针的其他属性：

- 原始指针不拥有它们的值。 Rust 编译器不会检查，当这些被访问时，所指数据仍然有效
- 允许指向相同数据的多个原始指针。每个原始指针都可以写，对数据的读写访问。这意味着 **Rust 没有时间保证共享数据有效**
- 也许某些操作系统调用或第三方代码需要原始指针。原始指针在提供外部接口的 C 代码中很常见
- 对某些东西的共享访问是必不可少的，运行时性能是最重要的。也许应用程序中的多个组件需要平等访问某些组件计算成本高的变量。

### Rust 指针生态

| Raw  Pointer | *const T    *mut T   快速，但不安全                          | 快速、 可与外部交互                                         | unsafe                                       |
| ------------ | ------------------------------------------------------------ | ----------------------------------------------------------- | -------------------------------------------- |
| Box<T>       | 将任何类型的数据存储到堆上                                   | 将值存储在称为“堆”的位置的中央存储器中                      | 动态类型尺寸                                 |
| Rc<T>        | 引用计数指针 Rc<T> 是 Rust 能干但吝啬的簿记员。它知道谁有借什么，什么时候借。 | 共享访问值                                                  | 非线程安全，运行成本，运行时尺寸增加         |
| Arc<T>       | Arc<T> 是 Rust 的大使。它可以跨线程共享值，保证这些值不会相互干扰 | 共享访问值、 线程安全                                       | 运行时成本、 运行时尺寸增加                  |
| Cell<T>      | 作为变形专家，Cell<T> 赋予了改变不可变值的能力               | 内部可变性                                                  | 运行时尺寸改变、performance                  |
| RefCell<T>   | 使用 RefCell<T> 对不可变引用执行变异。它令人费解的力量需要付出一些代价。 | 内部可变性、可以嵌套在 Rc 和 Arc 中，它们只接受不可变的引用 | 运行时尺寸增加、运行时消耗、缺乏编译时间保证 |
| Cow<T>       | 当你只需要阅读时，为什么要写下来？也许您只想进行修改。这就是 Cow 的角色（写时复制 | 仅使用读访问时避免写入                                      | 可能增加尺寸                                 |
| String       | String 向我们展示了如何构建安全的抽象                        | 根据需要动态增长、保证运行时正确解码                        | 过度分配大小                                 |
| Vec<T>       | 程序的主存储系统。 Vec<T> 在创建和销毁值时保持数据有序       | 根据需求动态增长                                            | 过度分配大小                                 |
| RawVec<T>    | Vec<T> 和其他动态大小类型的基石。了解如何根据需要为数据提供一个家。 | 根据需求动态增加大小、与内存分配器一起寻找空间              | 不直接适用于用户代码                         |
| Unique<T>    | 一个值的唯一所有者，一个唯一的指针保证拥有完全控制权。       | 字符串等类型的基础，需要独占值                              | 不适合直接用于应用程序代码                   |
| Shared<T>    | **分享所有权**很难。 Shared<T> 让其很轻松                  | 共享所有权、可以将内存与 T 的宽度对齐，即使是空的           | 不适合直接应用于程序代码                     |



- core::ptr::Unique 是 String、Box<T> 和指针字段 Vec<T> 等类型的基础。  
- core::ptr::Shared 是 Rc<T> 和 Arc<T> 的基础，它可以处理需要共享访问的情况

Rust的所有类型都分为两类：

- 可以安全地在内存中移动的类型。这是默认的，规范的。例如，这包括像数字、字符串、布尔值这样的原语，以及完全由它们组成的结构或枚举。大多数类型都属于这一类！
- 自引用类型，在内存中移动是不安全的。这些是非常罕见的。一个例子是一些 Tokio 内部结构中的侵入式链表。另一个例子是大多数实现 Future 并借用数据的类型

一些特例：

- 对于单线程和多线程程序，深度互连的数据结构可以分别从 `std::rc::Weak` 和 `std::arc::Weak` 中受益。这些允许在不增加引用计数的情况下访问 Rc/Arc 中的数据。这可以防止无休止的指针循环
- `alloc::raw_vec::RawVec` 类型是 `Vec<T>` 和` VecDeq<T>` 的基础。一个可扩展的双端队列，它理解如何以智能方式为任何给定类型分配和释放内存
- `std::cell::UnsafeCell` 类型位于 `Cell<T>` 和 `RefCell<T>` 之后。为自定义类型提供内部可变性

### 为程序提供存储的内存

堆栈最基本的区别：

- 栈很快
- 堆很慢

#### stack

-  栈实际上包含两层对象：   栈帧  +  数据
- 堆栈允许程序员访问存储在其中的多个元素，而不仅仅是顶部项目
- 堆栈可以包含任意大小的元素

> 堆栈上的项以**后进先出** (LIFO) 方式进行。堆栈中的项称为堆栈帧。堆栈帧是在进行函数调用时创建的。随着程序的进行，CPU 内的光标会更新以反映当前堆栈帧的当前地址。游标称为堆栈指针。 由于函数在函数内被调用，堆栈指针的值随着堆栈的增长而减少。当函数返回时，堆栈指针增加。  堆栈帧包含调用期间函数的状态。当一个函数在一个函数内被调用时，旧函数的值被有效地及时冻结。堆栈帧也称为激活帧。 堆栈帧包含用于其函数参数的空间、指向原始调用点的指针和局部变量（除了在堆上分配的数据）。

#### heap

堆是类型的程序内存区域，在编译时没有已知大小。 在 Rust 中，有两 意义。 某些类型会根据需要随时间增长和缩小。`String`和` Vec<T>`。 其他类型无法告诉 Rust 编译器分配多少内存，即使它们在运行时不会改变大小。 这些被称为`动态大小的类型`。 切片 ([T]) 是最常引用的示例。 切片没有编译时间长度。 在内部，这些是指向数组某些部分的指针。 但是切片 实际上表示该数组中的一些元素。另一个例子是 trait 对象，trait 对象允许 Rust 程序员通过以下方式模仿动态语言的一些特性允许多种类型嵌入同一个容器中。

二者最直接的区别则是  访问堆上的数据需要使用指针，而栈的数据并不需要

### 动态内存分配

当程序需要更多内存时，它需要向操作系统请求更多。 这称为动态内存分配，动态内存分配的步骤：

1. 通过系统调用从操作系统请求内存。 在 UNIX 操作系统系列中，此系统调用是 `alloc()`。 在 MS Windows 中，调用是 `HeapAlloc()`。
2. 在程序中使用分配的内存。
3. 通过 UNIX 系统的 free() 和 Windows 的 `HeapFree()` 将不需要的内存释放回操作系统

> 程序和操作系统之间有一个中介：分配器，它是一个专门的子程序，它在幕后嵌入到您的程序中。它通常会执行优化，以避免在操作系统和 CPU 中进行大量工作。访问堆栈上的数据很快，因为分配在堆栈上的函数的局部变量在 RAM 中彼此相邻。这有时称为连续布局。
>  连续布局对缓存友好。或者，在堆上分配的变量不太可能彼此相邻。此外，访问堆上的数据涉及取消引用指针。

| Stack  | Heap      |
| ------ | --------- |
| simple | complex   |
| safe   | dangerous |
| fast   | slow      |
| rigid  | flexible  |



堆栈的速度增加需要权衡。 在程序的生命周期内，堆栈上的数据结构必须保持相同的大小。 堆上分配的数据结构更加灵活。 因为这些是通过指针访问的，所以可以更改该指针。



> 访问程序中的数据需要虚拟地址——程序本身可以访问的唯一地址。这些被转换成物理地址。这个过程涉及程序、操作系统、CPU、RAM 硬件以及偶尔的硬盘驱动器和其他设备之间的协助。 CPU 负责执行此转换，但 OS 存储指令。
>
> CPU 包含一个专为这项工作设计的内存管理单元 (`MMU`)。对于每个正在运行的程序，每个虚拟地址都映射到一个物理地址。这些指令也存储在内存中的预定义地址。这意味着，在最坏的情况下，每次访问内存地址的尝试都会导致两次内存查找。但有可能避免最坏的情况。
>
> PU 维护最近转换地址的缓存。它有自己的（快速）内存来加速访问内存。由于历史原因，这个缓存被称为翻译后备缓冲区，通常缩写为 `TLB`。优化性能的程序员需要保持数据结构精简并避免深度嵌套的结构。达到 `TLB` 的容量（对于 `x86` 处理器通常为 100 页左右 `400KB`）的成本可能很高。
>
> 虚拟地址被分组为称为页面的块，其大小通常为 4 KB。这种做法避免了为每个程序中的每个变量存储转换映射的需要。每个页面具有统一的大小还有助于避免称为内存碎片的现象，即在可用 RAM 中出现一些空的但不可用的空间。

数据位于虚拟内存页(Virtual memory page)中时，操作系统和CPU 一些技巧：

- 拥有虚拟地址空间允许操作系统过度分配。可以容纳要求比机器物理提供更多内存的程序。
- 非活动内存页面可以以字节对字节的方式交换到磁盘，直到活动程序请求它为止。交换通常在内存争用高的时期使用，但也可以更普遍地使用
- 可以执行其他大小优化，例如压缩。程序看到它的内存完好无损。在后端，操作系统压缩了程序浪费的数据使用量。
- 程序能够快速共享数据。如果您的程序请求一大块零，例如，对于新创建的数组，操作系统可能会将您指向一个填充有零的页面，该页面当前正被其他三个程序使用。没有一个程序意识到其他程序正在查看相同的物理内存，并且零在它们的虚拟地址空间中具有不同的位置
- 分页可以加快共享库的加载。作为上一点的特例，如果共享库已经被另一个程序加载，操作系统可以通过将新程序指向旧数据来避免将其加载到内存中两次。
- 分页增加了程序之间的安全性。地址空间的某些部分是非法访问的。操作系统还有其他可以添加的属性。如果尝试写入只读页面，操作系统将终止该程序。

在日常程序中有效使用虚拟内存系统需要考虑数据在 RAM 中的表示方式。这里有一些指导方针：

- 将程序的热数据保持在4K以内，保持快速查找
- 如果 4 KB 对应用程序不合理，那么下一个要保持的目标是 4 KB * 100。这个粗略的指南应该意味着 CPU 可以很好地维护其翻译缓存（TLB）以支持程序。
- 避免使用指针式进行深度嵌套的数据结构。如果指针指向另一页，则性能会受到影响。
- 测试嵌套循环的顺序。 CPU 从 RAM 硬件读取小字节块，称为缓存线。在处理数组时，可以通过调查是按列还是按行进行操作来利用这一点。

> 注：虚拟化使这种情况变得更糟。如果您在虚拟机中运行应用程序，则管理程序还必须为其客户操作系统转换地址。这就是许多 CPU 附带虚拟化支持的原因，这可以减少这种额外的开销。在虚拟机中运行容器会增加另一层间接性，因此会增加延迟。对于裸机性能，请在裸机上运行应用程序



可执行文件（也称为二进制文件）虽然确切的过程取决于操作系统和文件格式。当可执行文件启动时，操作系统将正确的字节加载到正确的位置。一旦创建了虚拟地址空间，就可以告诉 CPU 跳转到 .text 段的开头，然后程序开始执行。



总结：

- 从 CPU 的角度来看，指针、引用和内存地址是相同的，但在编程语言级别上却有很大不同。
- 字符串和许多其他数据结构是用指针指向的后备数组实现的。
- 智能指针是指行为类似于指针但具有附加功能的数据结构。这些几乎总是会产生空间开销。此外，数据可以包括整数长度和容量字段或更复杂的东西，
- Rust 拥有丰富的智能指针类型集合。具有更多功能的类型通常会产生更大的运行时成本。
- 堆和栈是操作系统和编程语言提供的抽象。这些在 CPU 级别不存在。操作系统通常提供诸如内存分配之类的机制来检查程序的行为。

























