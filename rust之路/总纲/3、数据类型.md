# 变量

变量声明 关键字`let`

let  声明一个变量与函数进行绑定,Rust变量绑定的不同之处，let语句在左侧是一个模式，不单单是一个变量

Rust不同于其他的语言，**变量绑定必须要有一个初始化的值**

```rust
let(x,y)=(1,2);
```

## 类型注解

Rust 静态类型语言，拥有类型推断的功能，类型写在一个冒号（:）后面

```rust
let x:u32=3;
```

## 可变性

Rust中默认变量是不可变的，使用关键字`mut`将一个绑定变量变为可变

```rust
let mut x :i32=1;
println!("the first x is {}") //5
x=6
println!("the second x is {}",x); //6
```

注：println!中的`{}`是一个占位符，将后边的x的值插入到提前预留的位置。

## 变量的隐藏

一个后声明的位于同一作用域的相同名字的变量绑定将会覆盖前一个变量绑定。即重复使用`let`关键字并配以相同的名称来不断地隐藏变量

```rust
let  x :i32=1;
println!("the first x is {}") //1
let x =x+2
println!("the second x is {}",x); //3
```

隐藏机制不同于`mut`，如果不是在使用`let`关键字地情况下重新为这个变量赋值，则会导致编译错误，通过`let`对x进行了一系列变换，并允许这个变量在操作完成之后保持不变性。

另一个不同点则是，隐藏机制可以在变化的过程中修改原先数据的类型。隐藏并不改变和销毁被绑定的值，这个值会在离开作用域之前继续存在，即便无法通过任何手段访问到它。

## Unsize

Rust有一个特定的数字类型，用于对数组和集合进行索引，称为usize。usize被设计成能够引用一个数组中与可寻址内存一样多的元素。 如果内存是64位可寻址的，那么usize的长度是64位。isize是一个有符号的，但也有可用的。



## 数据类型

Rust数据类型：标量类型，复合类型

## 标量类型

内建4个基础的标量类型：整型、浮点数、布尔值、字符。

## 整型

没有小数部分的数字，Rust内建的整数类型

|  长度  | 有符号 | 无符号 |
| :----: | :----: | :----: |
| 8-bit  |   i8   |   u8   |
| 16-bit |  i16   |  u16   |
| 32-bit |  i32   |  u32   |
| 64-bit |  i64   |  u64   |
|  arch  | isize  | usize  |

`isize`和`usize`两种特殊类型的整数类型，其长度取决于程序 运行的目标平台，在64位平台上就是64位，在32位平台上就是32位。

## 浮点类型

Rust提供了两种浮点数类型`f32`和`f64`分别占据32位和64位内存，在Rust中默认将浮点数字面量类型推到位`f64`。

```rust
let x=6.44;    //f64
let y:f32=6.44; // f32
```

## 数值运算

对于数值类型，Rust支持常见的数学运算：加减乘除以及取余

```rust
let sum=5+10;
let difference=10-2;
let  product=4*5;
let quotient=32.01/20.1;
let remainder=43%5;
```

上述语句中右侧的表达式都使用了一个运算符，并将结果绑定到了左侧变量上。

## 布尔类型

Rust的布尔类型拥有两个可能的值：`ture`以及`false`,会占据单个字节的内存空间

```rust
fn main(){
	let f:bool=false;
}
```

其主要用途是在`if`表达式内作为条件使用

## 字符类型

Rust中`char`类型被用于描述语言中最基础的单个字符，值得注意的是char類型使用单引号指定，不同于字符串使用双引号指定。char 占据4个字节

```rust
let c='z';
```

### Str

Rust中的str类型是最原始的字符串类型，作为无尺寸的类型，其本身不是很有用，常放在一个引用后边`&str`

> str是内存中某个位置的不可变字节数组。str指向字符串对象时可能在堆上，如果字符串是静态的，则可能在全局内存中。str切片是&str，是对也包含长度值的str的引用。

### std::String

是一个堆分配的字符串类型，用于处理字符串。

内部UTF-8用于编码，而char是32位的。字符串的长度被认为是它的字节长度。有一些特殊的迭代器用于遍历字符串并将UTF-8解码为32位字符。最后，还有一个特定于平台的类型OSString，它处理操作系统如何看待字符串与Rust的任何差异。

### OsString OsStr

Rust可以识别有时需要从系统API传递或接收字符串。在这种情况下，您可以使用OsString，它允许在Rust和依赖于系统的字符串表示形式之间进行交换。在Windows上它将返回UTF-16字符串，在Linux/Unix系统上它将返回UTF-8。OsStr是OsString上的一个切片，类似于str和String。

Rust中處理字符串有兩種方式：一種是按照**字符處理**,即將字符串轉爲字符數組`[char]`,另一種則是直接按照**字節處理**  [u8]

- [char] 保證是高效的`Unicode`,但不一定是有效的`UTF-8`, 一般將其看作`UTF-32`。將字符數組轉換爲字符串時需要注意
- `[u8]` 不一定是有效的字符串，但是比[char]占據的内存少，將其轉換成字符串需要檢查`UTF-8` 編碼

對字符串的拼接使用`format!`，追加字符串使用`push`

將只包含`ASCII` 字符的字符串字面量轉爲字節序列可以直接使用`b "str"`  代替`as_byte` 



## 复合类型

将不同类型的值组合称为了一个类型的值，Rust提供了两种内置的基础复合类型：元组(tuple)和数组(array)

### 元组类型

元组可以将不同类型的多个值组合到一个符合类型中，其拥有一个固定的长度(意味者开发者无法在元组声明结束之后随意更改其中的元素)

```rust
let atup:(i32,f64,u16)=(1,1.2,6);
```

由于元组被视为一个单独的复合元素，所以整个元组被绑定到了变量`atup`上了，要获取元组中单独的元素需要`解构`

```rust
let (x,y,z)=atup;
println!("the atup x value is {} ",x);
```

除了解构还可以通过'.'来访问元组的值

```rust
let (x,y,z)=atup;
println!("the atup x value is {} ",atup.1);
```

值得一提的是.操作时访问下标是从0开始的

### 数组类型

不同于元组，数组的每个元素必须有相同的类型，且长度固定，在Rust的标准库中还提供了一种动态数组。

```rust
let a=[1,2,3,5]; // 普通数组
let a=vec![1,2,33,6]; //动态数组
```

普通数组由一整块分配在栈上的内存组成，可以通过索引来获取一个数组中的所有元素

```rust
let a=[1,2,3,5];
println!("array a the first value is {} ",a[0])
```

非法访问数组中的元素会造成panic

#### slice

“切片”是对另一个**数据结构的引用**(或者视图)它们对允许安全、高效地访问数组的一部分而无需复制。

从本质上讲，切片不是直接创建的，而是从现有变量。切片有一个长度，可以是可变的，也可以是不可变的。

```rust
let a=[1,2,34,5];
let middle=&a[1..3];
let copya=&a[..];
```



## 函数

Rust中的声明函数的关键字为`fn`且使用蛇形命名法(使用小写字母进行命名，并以下划线分割单词)

```rust
fn  fa(){
		println!("this is rust first function fa")
}
```

### 函数参数

在函数声明的时候定义，属于函数签名的一部分，是一种特殊的变量,在函数签名中必须显式的声明每个参数的类型，也正是参数的类型的被显式的声明了,编译器也无需进行类型推导了

```rust
fn sum(x:i32,y:i32)->i32{
	x+y
}
```

### 函数中的语句和表达式

Rust是基于表达式的语言，所以对于Rust来说语句不同于表达式。语句是执行操作，但不返回值的指令。表达式则是会进行计算，产生结果的指令。上述函数中的`x+y`就是一个表达式，而不是语句。(表达式本身也是语句的一部分，调用函数是表达式，调用宏也是表达式，创建新作用域的花括号也是表达式{})

因为语句没有返回值，所以不能将语句赋值给其他地变量

```rsut
let x=(let y=10);  //  这是行不通地
```

Rust中不允许"x=y=num;"的存在

```rust
fn sum(x:i32,y:i32)->i32{
	x+y
}
```

注意：`x+y`之后没有分号，如果之后有了分号，这段代码就成了语句而不谁返回任何值(并且会导致编译错误)。

这也说明Rust是**基于表达式的语言**。并且分号不同于其他基于`{}`和`;`的语言。

### 及早返回

Rust中关键字return

```rust
fn f1(x:i32)->i32{
	return x;
	x+1
}
```

结果为：x的值，而不是返回x+1

### 函数的返回值

Rust中函数的返回值在`->`之后，并且返回值等同于函数体最后一个表达式的值，可以使用`return`返回，大多数函数都是隐式的返回了最后的表达式。

### 发散函数

函数**没有返回值**

```rust
fn f2()->{
	panic!("no return");
}
```

发散函数可以是**任意类型**

```rust
let x:i32=f1();
let y:String=f1();
```



## 声明 VS 表达式

Rust 是一个主要基于表达式的语言，只有两种声明类型，并且其他一切都是表达式。

**表达式**返回一个**值**，声明不会

Rust中两中声明方式： 宣布声明+表达式声明

### 宣布声明：

在Rust中 一个变量绑定时使用let不是一个表达式

```rust
let x=(let y=3);
```

此时编译器回馈的消息则是期望一个表达式，但是let只是一个声明。

### 表达式声明

将任意的**表达式转为语句**。使用分号来区分表达式，







