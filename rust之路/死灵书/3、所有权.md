# 所有权

所有权让Rust可以彻底告别垃圾回收，同时做到内存安全和高效率。

## 引用

两种引用的类型：

- 共享指针 &
- 可变指针  &mut

遵循的规则：

- 引用的生命周期不能超过被引用内容
- 可变引用不能存在别名(alias)

Rust 实际上没有定义别名模型 `scream_cat:`

## 别名

对于别名的使用，在Rust中需要考虑到生命周期以及可变性，

- 将值放入缓存变量之中，因为可以确定没有指针可以访问变量的内存
- 省略一些读操作，因为可以确定上一次读内存之后，内存没有发生变化
- 省略一些写操作，可以确定在下一次写内存之前，内存不会被读取
- 移动或重排读写操作的顺序，可以确定它们并不互相依赖





## 省略

生命周期可以在输入也可以在输出：

- 对于fn定义的函数，**输入**指的是函数签名中的**参数**的类型，输出则是结果的类型。(fn方法定义中的输入位置不包括`impl`头处的生命周期，对于trait的默认的方法，不包括trait的头位置)
- 有可能会省略impl头位置处的生命周期。

### 省略规则：

1. 每一个在**输入位置省略**的生命周期都对应一个唯一的生命周期参数
2. 若只有一个生命周期，该声明周期会赋给所有省略了的**输出生命周期**。
3. 同时存在多个生命周期位置，而其中一个参数是`&self`或`&mut self`，那么self的生命周期会赋给所有省略的输出生命周期。

## 无界生命周期

> 非安全代码经常会凭空变出来一些引用和生命周期。这些生命周期都是无界的。最常见的场景是解引用一个裸指针，然后产生一个拥有无界生命周期的引用。这些生命周期根据上下文的要求，想要多大就可以有多大。这其实比简单的设为'static更加强大。比如&'static &'a T是无法通过类型检查的，但是无界生命周期可以完美适配&'a &'a T。不过大多数情况下，这种的无界生命周期会被视为`’static’。

> 几乎没有哪个引用是'static，所以这样很可能是错误的。

对于一个函数，任何不是从输入哪里来的输出生命周期是无界的，

```rust
fn get_str<'a>()->&'a str;
```

该函数会产生一个拥有无界生命周期的`&str`

最简单的避免无界生命周期的方式就是在函数声明中运用生命周期省略，若一个输出生命周期被省略了，其必须受限于一个输入生命周期。

> 当然它有可能被赋予了一个错误的生命周期，但是这样通常只会产生一个编译错误，总比允许它破坏内存安全要好。

在函数内部，限制生命周期范围是极易出错的，最安全且简单的限制生命周期的方法是将它作为一个有有界生命周期的函数的返回值。但是，如果这个不被接受，引用可以被设置成一个特别的生命周期。

## 高级trait边界(HRTB)

```RUST
use std::borrow::Borrow;

struct C<F>{
    data:(u8,u16),
    func:F,
}

impl <F>C<F>
    where F:Fn(&(u8,u16))->&u8,
{
    fn call(&self)->&u8{
        (self.func)(&self.data)
    }
}


fn f2(data:&(u8,u16))->&u8{
    &data.0
}

fn main() {
    let clo=C{data:(0,1),func:f2};
    println!("{}",clo.call());
}
```

高阶trait边界

```rust
where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,
```

注：其中`Fn(a, b, c） -> d`本身就是不确定的`Fn` trait的语法糖

`for<'a>`可以读作“对于`'a`的所有可能选择”，基本上表示一个无限的列表，包含所有`F`需要满足的trait边界。

除了`Fn` trait之外我们很少会遇到需要HRTB的场景，而且即使遇到了我们还有一个神奇的语法糖相助。

## 子类型

尽管Rust没有结构体继承的概念，它却有子类型机制。在Rust中，子类型是针对生命周期存在的。生命周期是代码的作用域，所以可以根据它们相互包含的关系判断他们的继承关系。

生命周期的子类型指的是：如果`'big: 'small`（big包含small，或者big比small长寿），那么`'big`就是`'small`的子类型。

> 如果需要一个在`'small`内有效的引用，实际指的是至少在`'small`中有效的引用。不在乎生命周期是不是完全的一致。从这点上来说，永久生命周期`'static`是所有生命周期的子类型。

高阶生命周期也是所有具体生命周期的子类型。这是因为一个随意变化的生命周期比特定的一个生命周期更通用。

*不能写一个接收`'a`类型的值的函数！生命周期只是别的类型的一部分*



### 变性

变性是类型构造函数与它的参数相关的一个属性。Rust中的类型构造函数是一个带有无界参数的通用类型。

构造函数F的变性表示了它的输入的子类型如何影响它输出的子类型。 Rust中的三种变性：

1. T为U的子类型时，F<T>也是F<U>的子类型，则F对于T是**协变**的。
2. T为U的子类型时，F<U>是F<T>的子类型，F对于T是**逆变**的
3. 子类型之间没有关系，则F对于T是**不变**的

注：在Rust中协变性远比逆变性要普遍和重要，逆变性的存在几乎可以忽略

部分可变性：

- &‘a  T 对于 ‘a 和T 是协变的
- &‘a mut T 对于’a是协变的，对于T 是不变的
- fn(T)-> U 对于T 是逆变的，对于U是协变的
- Box ，Vec 以及所有的集合类型对于他们保存的类型都是协变的
- UnsafeCell<T>, Cell<T>, RefCell<T>,Mutex<T> 和其他的内部可变类型对于T都是不变的

变性的基本原则：生命周期较短的内容有可能存储在生命周期更长的变量里，这时必须要求变性是不变的。

*对于可变引用，总有一些地方（被引用的原始值）记着类型的信息并且假设它们不会改变。如果我们改变了这些信息，原始值的位置就可能出现异常。*

> `&'a mut T`对于`'a`却是协变的。`'a`和`T`最关键的区别是`'a`是引用**自身**的属性，而**T**则是**引用借用**的。如果改变了T的类型，T的原始值依然记着它的类型。可如果改变的是生命周期的类型，只有引用自己知道这一变化，因此这是安全的。换句话说，**`&'a mut T`拥有`'a`，但是仅仅借用T。**



> cell类型的不变性可以这样理解：对于cell来说`&`就是`&mut`，因为你可以通过`&`储存值。所以cell必须是不变的，以避免生命周期缩短的问题。



Box和Vec 都是协变的：

- 子类型通过值发生变化，原有的记录类型信息的位置会被移除，即容器再也不能使用原有的值，也无需担心在其他的地方记录着类型的信息。（通过使用子类型特性会彻底销毁原有类型的信息）

  ```rust
  fn get_box<'a>(str: &'a str) -> Box<&'a str> {
      // 字符串字面量是&'static str类型，但是我们完全可以“忘掉”这一点，
      // 就让调用者认为这个字符串的生命周期只有这么短
      Box::new("hello")
  }
  ```

- 子类型通过引用发生变化，那么容器以`&mut Vec<T>`类型传递，可是`&mut`对于它引用的值是不变的，所以`&mut Vec<T>`对于`T`实际也是不变的。那么`Vec<T>`对于`T`协变这件事在引用的情况下就完全不重要了。

fn 具有混合变性，也是唯一用到了逆变性的地方

```rust
fn  foo(&'a str)->usize;
```



`*const`和`&`有着完全一样的语义，所以变性也是一样的。`*mut`正相反，它可以解引用出一个`&mut`，所以和cell一样，它也是**不变的**。

自定义类型：

，结构体会继承它的成员的变性。如果结构体`Foo`有一个成员`a`，它使用了结构体的泛型参数`A`，**那么`Foo`对于`A`的变性就等于`a`对于`A`的变性**。可如果`A`被用在了多个成员中：

- A均为协变=====》  foo 对于A 协变
- A均为逆变=====》   foo 对于A逆变
- 其余情况均为不变

```R
use std::cell::Cell;
struct Foo<'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H, In, Out, Mixed> {
    a: &'a A,     // 对于'a和A协变
    b: &'b mut B, // 对于'b协变，对于B不变
    c: *const C,  // 对于C协变
    d: *mut D,    // 对于D不变
    e: E,         // 对于E协变
    f: Vec<F>,    // 对于F协变
    g: Cell<G>,   // 对于G不变
    h1: H,        // 对于H本该是可变的，但是……
    h2: Cell<H>,  // 其实对H是不变的，发生变性冲突的都是不变的
    i: fn(In) -> Out,       // 对于In逆变，对于Out协变
    k1: fn(Mixed) -> usize, // 对于Mix本该是逆变的，但是……
    k2: Mixed,              // 其实对Mixed是不变的，发生变性冲突的都是不变的
}
```

**一个安全地实现Drop的类型，它的泛型参数生命周期必须严格地长于它本身**



##  幽灵数据

某些情况：类型或生命周期逻辑上与一个结构体相关联，但却不属于结构体的任何一个成员，例如：

```rust
struct Iter<'a,T:'a>{
	ptr:*const T,
    end:*const T,
}
```

‘a 并没有在Iter中使用，它是无界的，无界生命周期和类型禁止出现在结构体定义中。所以想办法在结构体内用到这些类型，这也是正确的变性检查和drop检查的必要条件。

使用PhantomData 标记

PhantomData 不消耗存储空间，只是模拟了某种类型的数据，以方便静态分析，还能提供drop检查需要的信息



```rust
use std::marker;
struct Iter<'a,T:'a>{
    ptr:*const T,
    end:*const T,
    _marker:marker::PhantomData<&'a T>,
}
```

如此生命周期变为有界的，对于‘a和T 也是可变的



裸指针拥有数据，标准库提供了一个`Unique<T>`的组件

-  封装一个*const T 处理变性
- 包含一个PhantomData
- 自动实现Send/Sync，模拟包含T时一样的行为
- 将指针标记为NonZero以便于空指针优化



PhantomData 模式表

| Phantom 类型                | `'a` | `'T`                   |
| :-------------------------- | :--- | :--------------------- |
| `PhantomData<T>`            | -    | 协变（可触发drop检查） |
| `PhantomData<&'a T>`        | 协变 | 协变                   |
| `PhantomData<&'a mut T>`    | 协变 | 不变                   |
| `PhantomData<*const T>`     | -    | 协变                   |
| `PhantomData<*mut T>`       | -    | 不变                   |
| `PhantomData<fn(T)>`        | -    | 逆变(*)                |
| `PhantomData<fn() -> T`     | -    | 协变                   |
| `PhantomData<fn(T) -> T>`   | -    | 不变                   |
| `PhantomData<Cell<&'a ()>>` | 不变 | -                      |

(*)如果发生变性的冲突，这个是不变的

## 分解引用

？？？
