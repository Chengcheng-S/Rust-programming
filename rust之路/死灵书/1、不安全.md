# 安全和不安全

Rust是安全和不安全的代码，其间的交互是靠**unsafe**关键字分离，

Rust是安全的原因：所有的**非安全代码都被unsafe隔离在外，**可以在程序的根部添加**#![forbid(unsafe_code)]**保证代码的安全性。

unsafe关键字的含义： 1) 声明代码中存在编译器无法检查的安全规范；2）声明开发者会自觉遵守相关规范而不会主动破坏

使用关键字unsafe表明函数和trait的声明不存在不受编译器检查的规范，对于**函数** *unsafe表示函数的开发者必须查阅函数的文档以确保他们的用法符合函数的安全要求*，对于**trait**而言，*unsafe 意味者实现trait的开发者必须查阅trait的文档以确保trait的实现符合安全要求。*

标准库中的非安全函数：

- `slice::get_unchecked`，可接受**不检查的索引值**，也就是**存在内存安全机制被破坏**的可能
- `mem::transmute`将值**重新解析**成**另一种类型**，即允许*随意绕过类型安全机制的限制*
- 所有指向**确定大小类型的裸指针**都有`offset`方法，当传入的**偏移量越界**时将导致**未定义行为**(Undefined Behavior)
- 所有FFI函数都是**unsafe**的，其他的语言可以做各种的操作而**Rust编译器无法**检查它。

Rust中的两个非安全的trait：

- `Send`是一个标志trait(没有任何方法的trait)，所有的实现都可以安全地发送(move)到另一个线程
- `Sync`也是一个标志trait ,线程可以通过共享的引用共享它的实现。

`Send`和`Sync`被标识为非安全是因为线程安全性是一个底层特性，Send和Sync 会被各种类型**自动**实现的，只要这种**实现**证明是**安全**的。如果一种类型其所有的值的类型都实现了Sync，它本身就会自动实现Sync(Send 也是如此)，将其设置为unsafe实际减少了非安全代码的滥用。

**安全Rust代码都不能导致未定义行为**

> 安全和非安全的Rust之间存在一种不对称的信任关系。安全Rust必须无条件信任非安全Rust，假定所有与之打交道的非安全代码都是正确的。反过来，非安全Rust却要谨慎对待安全Rust的代码。



Rust中有`PartialOrd`和`Ord`两个trait，区别则是前者仅表示可以被比较的类型，而后者则表示实现了完整顺序(toal ordering)的类型

`BtreeMap`只有在键完整顺序时才能正常工作，所以他要求它的键必须是实现`ord`,到那时BtreeMap内部实现却依赖于非安全Rust。

因为如果`Ord`的实现本身是错误的（尽管代码是安全的）将导致未定义行为，所以`BTreeMap`内部的非安全代码必须对那些实际上没有做到完整顺序的`Ord`保持足够的鲁棒性——虽然完整顺序本身是我们选择`Ord`的唯一理由。

非安全Rust不能简单信任安全Rust都是正确的。即 传入到BtreeMap的值不具备完整顺序，`BTreeMap`的行为将会完全混乱。它仅仅能保证不会产生未定义行为罢了。

## Unsafe的用途

- 解引用裸指针
- 访问非安全函数
- 修改或访问可变的静态变量
- 实现非安全的trait
- 访问union

不同于C，Rust充分限制了可能出现的未定义行为的种类，语言核心只需要防止几种行为：

1. 解引用null空指针，悬垂指针、未赋值的指针
2. 读取未初始化的内存
3. 破坏指针混淆规则
4. 创建非法的基本类型
   - 悬垂引用和null引用
   - 空的`fn`指针
   - 0和1之外的布尔值
   - 未定义的枚举类型的项
   - 非utf-8编码的str
   - 在[0x0,0xD&FF]和[0xE000,0x10FFFF]以外的`char`类型值
5. 不谨慎的调用其他语言
6. 数据竞争

Rust语言自身可以导致未定义行为的操作就只有这些，当然，**非安全函数和trait可以声明自己专有的安全规范**.要求开发者必须遵守以避免未定义的行为。比如：allocator API 声明回收一段未分配的内存是未定义行为。

编译器内联函数也可能引入一些规则，一般是针对代码优化的假设条件。比如：Vec和Box使用的内联函数要求传入的指针永远不能为`null`

Rust对于一些模糊的操作则是通常比较宽容的，Rust会认为以下的操作是安全的：

- 死锁
- 竞争条件
- 内存泄漏
- 调用析构函数失败
- 整型值溢出
- 终止程序
- 删除产品数据库

当然，有以上行为的程序极有可能就是错误的。Rust提供了一系列的工具减少这种事情的发生，但是完全地杜绝它们其实是不现实的。

## 编写非安全程序

Rust明确限制非安全Rust代码的作用域























