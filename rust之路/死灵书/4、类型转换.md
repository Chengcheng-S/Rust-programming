# 类型转换

某些情况下，类型会被隐式的强制转换，这些转换通常导致类型被“弱化”，主要针对**指针和生命周期**，主要目的是让Rust适用于更多的场景，基本上是无害的。

包括：

- 传递性：当T1 强转为T2，T2强转为T3时，T1可以强转为T3
- 指针弱化：
  - &mut T ==>&T
  - *mut ==>  *const T
  - &T  ==>*const T
  - &mut T ==> *mut T
- Unsize : 如果T 实现了 `CoereceUnsized<U>` ,那么T 可以强转为U
- 强制解引用： 若T 可以解引用为U (T:Deref<Target=U>),那么 &x(&T的类型表达式)，可以强制转换为&U类型的 &*x

所有的指针类型(包含智能指针Box,Rc)都是实现了

```rust
CoereUnsiezed<Pointer<U>>for Pointer<T>where T:Unsize<U>
```

Unsize 只能被自动实现，并且出现如下的转换方式：

- [T:N] =>[T]
- T =>Trait  其中 T:Trait
- Foo <…,T,…>  => Foo<…,U,…>, 其中：
  - T:Unsize<U>
  - Foo  是一个**结构体**
  - 只有Foo的最后一个成员是和T有关的类型
  - 其他成员类型和T无关
  - 若最后一个成员的类型是Bar<T>,那么必须有Bar<T>:Unsize<Bar<U>>

强制类型转换会在“强转”的位置处发生，每一个显式声明了类型的位置都会引起该类型的强制转换，但如果**必须进行类型推断，则不会发生类型转换。**

表达式e到类型U的强制转换位置包括：

-  let 表达式，静态变量或常量： let x:U=e
- 函数参数  f1(e)
- 函数返回值 ： fn f2()->U{e}
- 结构体初始化： Foo{some_u:e}
- 数组初始化： let x:[u:10]=[e,…]
- 元组初始化：`let x: (U, ..) = (e, ..)`
- 代码块中的最后一个表达式：`let x: U = { ..; e }`

注意，在匹配**trait**的时候**不会**发生强制类型转换(receive 除外)

**如果为`U`实现了一个trait，`T`可以强制转换为`U`，并不能认为`T`也实现了这个trait。**

## 显式类型转换

显式类型转换是强制类型转换的超集：所有的强制类型转换都可以通过显式转换的方式主动触发。但有一些场景只适用于显式转换。有潜在危险，应用稀少

必须通过关键字`as` 主动触发

转换一般是针对裸指针和基本数字类型的。虽然说过它们存在风险，但是在运行期却是很稳定的。如果类型转换操作触发了一些奇怪的边界场景，Rust并不会给出任何提示。转换仍然会被认为是成功的。这就要求**显式类型转换必须在类型层面是合法的，否则会在编译期被拒绝。**

显式类型转换不属于非安全(unsafe)行为，因为仅凭转换操作是不会违背内存安全性的。

显示转换的情况：

- *T as *U 其中T，U  Sized
- *T as *Y  明确unsized的情况
- *T  as  integer
- integer as  *T
- number  as  number
- 无成员枚举  as integer
- bool  as integer
- char  as integer
- u8 as char
- &[T;N] as *const T
- fn as *T    T:Sized
- fn as integer

注：裸slice转换后长度会发生变化

显式转换不可传递 ，`e as U1 as U2`是合法的表达式，也不能认为`e as U2`就一定是合法的。

对于数字类型转换，注：

- 相同大小的整型相互转换(如 i32->u32) 是一个 no-op
- 大尺寸int -> 小尺寸的int  会被截断
- 小尺寸的int -> 大尺寸的int
  - 若为源类型，无符号 将会补零
  - 有符号，将会符号补零
- 浮点类型转为整型 会舍去浮点数部分
  - 注：*若目标整数类型不能表示舍入的结果，在目前仍未被定义*  包括NaN ，lnf 
- 整数转为浮点数会长生这个整型的浮点型表示
- f32转换为f64可以无损失地完美转换，必要的时候做舍入（舍入到最近的可能取值，距离相同的取偶数）
- f64转换为f32会生成最近可能值（舍入到最近的可能取值，距离相同的取偶数）

## 变形

mem::transmute<T,U>接受一个T类型的值，然后将其重新解析为类型U，唯一限制便是**T和U必须有同样的大小**。

- 创建任意类型的处于不合法状态的示例，都将产生不可预知的混乱
- transmute有一个重载的返回类型，若没有明确只当返回类型，它会返回一个满足类型推断的类型
- 使用不合法的值构建基本类型是未定义的行为
- 非repr(C)的类型之间相互变形是未定义的行为。
- & 变形为&mut 是未定义的
  - & ===> &mut  永远是未定义的
- 变形为一个未指定生命周期的引用产生无界生命周期

mem::transmute_copy<T, U>， 从&T拷贝 size_of<U>个字节并将其解析为U。

`mem::transmute`仅有的类型大小的检查都不见了（因为拷贝类型前缀有可能是合法的），只不过`U`的尺寸比`T`大会被视为一个未定义行为。
