# 并发

## 数据竞争与数据竞争条件

数据竞争：

-  两个或者两个以上的线程并发地访问同一块内存
- 其中一个线程做写操作
- 其中一个线程是非同步地

数据竞争导致未定义的行为，所以不能在安全Rust中存在。绝大多数情况下，Rust所有权系统可以避免数据竞争；**不可能有可变引用的别名**，因此也就不能有数据竞争。

但是**Rust并不会避免一般竞争条件**

竞争条件自己不能违反Rust的内存安全性。只有配合上其他的非安全代码，竞争条件才有可能破坏内存安全。

```rust
use std::thread;
use std::sync::atomic::[AtomicUsize,Ordering];
use std::sync::Arc;

let data=vec![1,2,3,4];

let idx=Arc::new(AtomicUsize::new(0));
let other_idx=idx.clone();

thread::spawn(move||{
    other_idx.fetch_add(10,Ordering::SeqCst);
});

println!("{}",data[idx.load(Ordering::SeqCst)]);
```

Arc 可以在线程间进行引用计数。

使用原子中的值做索引，这是安全的，只读取了一次原子的内存，然后读出值得拷贝传递给了vec做索引，索引过程可以做正确的边界检查，在执行索引期间这个值也不会发生改变。

但是，如果上面的线程在执行这句代码之前增加了这个值，这段代码会panic。这符合竞争条件，因为程序执行得正确与否（panic几乎不可能是正确的） 依赖于线程得执行顺序。

## Send和Sync

- 若一个类型可以安全得传递给另一个线程，这个类型就是Send
- 若一个类型可以安全得被多个线程共享(也就是&T得Send)，这个类型是Sync

`Send`和`Sync`是Rust并发机制的基础。二者都是**非安全的trait**，因此其实现也是非安全的，而其他的非安全代码则可以假设这些实现是正确的。

由于它们是标志trait（它们**没有任何关联的方法**）“正确地实现”仅仅意味着实现满足它所需要的内部特征。不正确地实现`Send`和`Sync`会导致未定义行为。

Send和Sync还是自动推导的trait，和其他trait不同，**如果一个类型完全由Send和Sync组成，那么这个类型本身也是Send和Sync的**

**几乎所有的基本类型都是`Send`和`Sync`**，

例外：

- 裸指针非Send和Sync(其没有安全性保证)
- UnsafeCell不是Sync(所以 Cell和RefCell也不是)
- Rc不是Send和Sync (引用计数是共享器非同步的)

`Rc`和`UnsafeCell`是典型的非线程安全的：它们允许非同步地共享可变状态。

> 裸指针严格来说并不一定非得是非线程安全不可。通过裸指针做任何有意义的事情都需要先对它解引用，这一步就已经是非安全的了。从这个角度来说，有人可能会认为把它标为线程安全的也未尝不可。

上述的类型被标为非线程安全的主要目的是**避免包含他们的类型自动称为线程安全的**。

一个包含`*mut`的类型绝对不能是线程安全的。

自定义类型实现Send和Sync

```rust
struct MyBox(*mut u8);
unsafe impl Send for MyBox{}
unsafe impl Sync for MyBox{}
```

一个类型被自动推导为`Send`或`Sync`，但是它其实不满足二者的要求。此时可以去掉`Send`和`Sync`的实现：

```rust
#![feature(option_builtin_traits)]

struct SpecialThreadToken(u8);
impl !send for SpecialThreadToken {}
impl !Sync for SpecialThreadToken {}
```

注：一个类型不可能被不正确的推导为Send和Sync。 只有当类型和其他的非安全代码一起实现了一些特殊的行为时，它才可能会成为一个不正确的Send或Sync。

## 原子操作

Rust借鉴了C11关于原子操作的内存模型。

Rust暴露的排序方式包括：

- 顺序一致性(SeqCst)
- 释放(Release)
- 获取(Acquire)
- Relaxed

### 顺序一致性

顺序一致性是所有排序方式中最强大的，包含了其他所有排序方式的约束条件。直观上看，顺序一致性操作不能被重排：在同一个线程中，SeqCst之前的访问永远在它之前，之后的访问永远在它之后。只使用顺序一致性原子操作和数据访问就可以构建一个无数据竞争的程序，这种程序的好处是它的命令在所有线程上都有着唯一的执行流程。而且这个执行流程又很容易推导：它就是每个线程各自执行流程的交叉。

即使是在强顺序平台上，顺序一致性也会产生内存屏障。

### 获取-释放

获取和释放经常成对出现。它们的名字就提示了它们的应用场景：它们适用于获取和释放锁，确保临界区不会重叠。

acquire保证在它之后的访问永远在它之后。可在它之前的操作却有可能被重排到它后面、类似的，release保证它之前的操作永远在它之前。但是它后面的操作可能被重排到它前面。

> 当线程A释放了一块内存空间，紧接着线程B获取了同一块内存，这时因果关系就确定了。在A释放之前的所有写操作的结果，B在获取之后都能看到。但是，它们和其他线程之间没有确定因果关系。同理，如果A和B访问的是不同的内存，它们也没有因果关系。

释放-获取的基本用法：获取一块内存并进入临界区，然后释放内存并离开临界区。

在强顺序平台上，大多数的访问都有释放和获取的语义，释放和获取通常是无开销的。在弱顺序平台上不是这样。

### Relaxed

Relaxed访问是最弱的。它们可以被随意重排，也没有先后关系。但是Relaxed操作依然是原子的。

并不算是数据访问，所有对它的读-修改-写操作都是原子的。

在强顺序平台上使用Relaxed没什么好处，因为它们通常都有释放-获取语义。不过，在弱顺序平台上，Relaxed可以获取更小的开销。

